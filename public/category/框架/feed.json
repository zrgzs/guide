{
    "version": "https://jsonfeed.org/version/1",
    "title": "卓软信息工作室 • All posts by \"框架\" category",
    "description": "",
    "home_page_url": "https://zrgzs.github.io/guide",
    "items": [
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/",
            "title": "Docker安装以及使用",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<p>本篇文章介绍在 centos 上安装 docker。docker 目前支持 centos7, 要求内核不低于 3.10</p>\n<h2 id=\"一-保姆级安装教程\"><a class=\"markdownIt-Anchor\" href=\"#一-保姆级安装教程\">#</a> 一、保姆级安装教程</h2>\n<h3 id=\"1-卸载之前安装的docker\"><a class=\"markdownIt-Anchor\" href=\"#1-卸载之前安装的docker\">#</a> 1、卸载之前安装的 docker</h3>\n<figure class=\"highlight latex\"><figcaption data-lang=\"LaTeX\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum remove docker <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></span>                  docker-client <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></span>                  docker-client-latest <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></span>                  docker-common <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></span>                  docker-latest <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></span>                  docker-latest-logrotate <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></span>                  docker-logrotate <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></span>                  docker-selinux <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></span>                  docker-engine-selinux <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></span>                  docker-engine <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></span>                  docker-ce</pre></td></tr></table></figure><h3 id=\"2-配置yum工具\"><a class=\"markdownIt-Anchor\" href=\"#2-配置yum工具\">#</a> 2、配置 yum 工具</h3>\n<figure class=\"highlight latex\"><figcaption data-lang=\"LaTeX\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum install -y yum-utils <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></span>           device-mapper-persistent-data <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></span>           lvm2 --skip-broken</pre></td></tr></table></figure><h3 id=\"3-更新本地镜像源\"><a class=\"markdownIt-Anchor\" href=\"#3-更新本地镜像源\">#</a> 3、更新本地镜像源</h3>\n<figure class=\"highlight latex\"><figcaption data-lang=\"LaTeX\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># 设置docker镜像源</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>yum-config-manager <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></span>    --add-repo <span class=\"token function selector\">\\</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></span>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>sed -i 's/download.docker.com/mirrors.aliyun.com<span class=\"token function selector\">\\/</span>docker-ce/g' /etc/yum.repos.d/docker-ce.repo</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>yum makecache fast</pre></td></tr></table></figure><h3 id=\"4-安装docker\"><a class=\"markdownIt-Anchor\" href=\"#4-安装docker\">#</a> 4、安装 docker</h3>\n<figure class=\"highlight latex\"><figcaption data-lang=\"LaTeX\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum install -y docker-ce</pre></td></tr></table></figure><h3 id=\"5-启动docker\"><a class=\"markdownIt-Anchor\" href=\"#5-启动docker\">#</a> 5、启动 docker</h3>\n<p>docker 需要用到各种端口，为了方便学习，我直接把防火墙关了，并且不让开机自启。</p>\n<figure class=\"highlight latex\"><figcaption data-lang=\"LaTeX\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># 关闭</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>systemctl stop firewalld</pre></td></tr><tr><td data-num=\"3\"></td><td><pre># 禁止开机启动防火墙</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>systemctl disable firewalld</pre></td></tr></table></figure><p>启动 docker</p>\n<figure class=\"highlight latex\"><figcaption data-lang=\"LaTeX\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl start docker  # 启动docker服务</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>systemctl stop docker  # 停止docker服务</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>systemctl restart docker  # 重启docker服务</pre></td></tr></table></figure><p>查看是否启动成功</p>\n<figure class=\"highlight latex\"><figcaption data-lang=\"LaTeX\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker -v</pre></td></tr></table></figure><p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220620.jpg\" alt=\"image.png\"> 显示如下内容即表示安装成功。</p>\n<h3 id=\"6-配置镜像加速器\"><a class=\"markdownIt-Anchor\" href=\"#6-配置镜像加速器\">#</a> 6、配置镜像加速器</h3>\n<p>docker 官方镜像仓库网速较差，我们需要设置国内镜像服务：这玩意不是我能教的，你得看官网。参考阿里云的镜像加速文档：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220623.jpg\" alt=\"image.png\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20vY24taGFuZ3pob3UvaW5zdGFuY2VzL21pcnJvcnM=\"> 阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台</span></p>\n<p>配置 mysql:</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run <span class=\"token operator\">--</span>name mysql <span class=\"token operator\">-</span>e <span class=\"token constant\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span>wyr0307 <span class=\"token operator\">-</span>p <span class=\"token number\">13306</span><span class=\"token operator\">:</span><span class=\"token number\">3306</span> <span class=\"token operator\">-</span>v <span class=\"token operator\">/</span>tmp<span class=\"token operator\">/</span>mysql<span class=\"token operator\">/</span>conf<span class=\"token operator\">/</span>hmy<span class=\"token punctuation\">.</span>cnf<span class=\"token operator\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>mysql<span class=\"token operator\">/</span>conf<span class=\"token punctuation\">.</span>d<span class=\"token operator\">/</span>hmy<span class=\"token punctuation\">.</span>cnf <span class=\"token operator\">-</span>v <span class=\"token operator\">/</span>tmp<span class=\"token operator\">/</span>mysql<span class=\"token operator\">/</span>data<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token keyword\">var</span><span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>mysql\t<span class=\"token operator\">--</span>restart<span class=\"token operator\">=</span>always <span class=\"token operator\">-</span>d mysql</pre></td></tr></table></figure><p>配置 redis 命令：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run <span class=\"token operator\">--</span>name redis <span class=\"token operator\">-</span>p <span class=\"token number\">6379</span><span class=\"token operator\">:</span><span class=\"token number\">6379</span> <span class=\"token operator\">-</span>d redis redis<span class=\"token operator\">-</span>server <span class=\"token operator\">--</span>requirepass wyr0307</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>docker run <span class=\"token operator\">-</span>p <span class=\"token number\">6379</span><span class=\"token operator\">:</span><span class=\"token number\">6379</span> <span class=\"token operator\">--</span>privileged<span class=\"token operator\">=</span><span class=\"token boolean\">true</span> <span class=\"token operator\">--</span>name redis <span class=\"token operator\">-</span>v <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>docker<span class=\"token operator\">/</span>redis<span class=\"token punctuation\">.</span>conf<span class=\"token operator\">:</span><span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>redis<span class=\"token operator\">/</span>redis<span class=\"token punctuation\">.</span>conf <span class=\"token operator\">-</span>v <span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>docker<span class=\"token operator\">/</span>data<span class=\"token operator\">:</span><span class=\"token operator\">/</span>data <span class=\"token operator\">-</span>d docker<span class=\"token punctuation\">.</span>io<span class=\"token operator\">/</span>redis<span class=\"token operator\">:</span><span class=\"token number\">6.0</span> redis<span class=\"token operator\">-</span>server <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>redis<span class=\"token operator\">/</span>redis<span class=\"token punctuation\">.</span>conf <span class=\"token operator\">--</span>appendonly yes</pre></td></tr></table></figure><p>配置 nacos 命令</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run <span class=\"token operator\">-</span>d <span class=\"token operator\">--</span>name nacos  <span class=\"token operator\">-</span>p <span class=\"token number\">8848</span><span class=\"token operator\">:</span><span class=\"token number\">8848</span>  <span class=\"token operator\">-</span>p <span class=\"token number\">9848</span><span class=\"token operator\">:</span><span class=\"token number\">9848</span> <span class=\"token operator\">-</span>p <span class=\"token number\">9849</span><span class=\"token operator\">:</span><span class=\"token number\">9849</span> <span class=\"token operator\">--</span>privileged<span class=\"token operator\">=</span><span class=\"token boolean\">true</span> <span class=\"token operator\">-</span>e <span class=\"token constant\">JVM_XMS</span><span class=\"token operator\">=</span><span class=\"token number\">256</span>m <span class=\"token operator\">-</span>e <span class=\"token constant\">JVM_XMX</span><span class=\"token operator\">=</span><span class=\"token number\">256</span>m <span class=\"token operator\">-</span>e <span class=\"token constant\">MODE</span><span class=\"token operator\">=</span>standalone <span class=\"token operator\">-</span>v <span class=\"token operator\">/</span>tmp<span class=\"token operator\">/</span>nacos<span class=\"token operator\">/</span>conf<span class=\"token operator\">/</span>conf<span class=\"token operator\">:</span><span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>nacos<span class=\"token operator\">/</span>conf <span class=\"token operator\">-</span>v <span class=\"token operator\">/</span>tmp<span class=\"token operator\">/</span>nacos<span class=\"token operator\">/</span>logs<span class=\"token operator\">:</span><span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>nacos<span class=\"token operator\">/</span>logs <span class=\"token operator\">--</span>restart<span class=\"token operator\">=</span>always nacos<span class=\"token operator\">/</span>nacos<span class=\"token operator\">-</span>server<span class=\"token operator\">:</span>v2<span class=\"token punctuation\">.</span><span class=\"token number\">1.0</span></pre></td></tr></table></figure><p>配置 rabbitMq 命令</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run <span class=\"token operator\">-</span>e <span class=\"token constant\">RABBITMQ_DEFAULT_USER</span><span class=\"token operator\">=</span>lyggwsp <span class=\"token operator\">-</span>e <span class=\"token constant\">RABBITMQ_DEFAULT_PASS</span><span class=\"token operator\">=</span>wyr0307 <span class=\"token operator\">--</span>name mq <span class=\"token operator\">--</span>hostname mq1 <span class=\"token operator\">-</span>p <span class=\"token number\">15672</span><span class=\"token operator\">:</span><span class=\"token number\">15672</span>  <span class=\"token operator\">-</span>p <span class=\"token number\">5672</span><span class=\"token operator\">:</span><span class=\"token number\">5672</span> <span class=\"token operator\">-</span>d rabbitmq<span class=\"token operator\">:</span><span class=\"token number\">3</span><span class=\"token operator\">-</span>management</pre></td></tr></table></figure><p>配置 minio 命令</p>\n<h2 id=\"二-docker的基本操作\"><a class=\"markdownIt-Anchor\" href=\"#二-docker的基本操作\">#</a> 二、Docker 的基本操作</h2>\n<h3 id=\"镜像相关命令\"><a class=\"markdownIt-Anchor\" href=\"#镜像相关命令\">#</a> 镜像相关命令</h3>\n<p>镜像名称一般分两部分组成：[repository]:[tag]。在没有指定 tag 时，默认是 latest，代表最新版本的镜像<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220626.jpg\" alt=\"image.png\"> 相关操作：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220628.jpg\" alt=\"image.png\"> 使用如下网址可查看需要什么镜像。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL3JlZGlz\">Docker</span> 查看命名： docker XX --help 拉取镜像：docker pull nginx 移除镜像：docker rmi 查看拉取到的镜像：docker images 导出镜像到磁盘 ：docker save 加载镜像：docker load</p>\n<p>docker 容器相关命令：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220631.jpg\" alt=\"image.png\"> 创建运行一个 nginx 容器步骤一：去 docker hub 查看 nginx 的容器运行命名 docker run --name containerName -p 80:80 -d nginx 参数解读:docker run : 创建并允许一个容器–name : 给容器起的名字 - p：将宿主主机端口与容器端口映射，冒号左面是宿主主机端口，右侧是容器端口 - d: 后台允许 nginx : 镜像名称，例如 nginx<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220633.jpg\" alt=\"image.png\">docker run 命令的常见参数有哪些？–name：指定容器名称 - p：指定端口映射 - d：让容器后台运行查看容器日志的命令：docker logs 添加 -f 参数可以持续查看日志查看容器状态：docker ps</p>\n<p>如何进入 docker 容器内部来修改指定的操作？步骤一、进入容器，进入我们创建的 nginx 容器的命令为 docker exec -it mynginx bash 命令解读：docker exec : 进入容器内部，执行一个命令 - it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器进行交互 mn : 要进入的容器的名称 bash : 进入容器后执行的命令，bash 是一个 linux 终端交互命令步骤二、查看官网，查找文件存放的位置来进行指定的操作。</p>\n<h4 id=\"查看容器状态\"><a class=\"markdownIt-Anchor\" href=\"#查看容器状态\">#</a> 查看容器状态：</h4>\n<p>docker ps 添加 - a 参数查看所有状态的容器</p>\n<h4 id=\"删除容器\"><a class=\"markdownIt-Anchor\" href=\"#删除容器\">#</a> 删除容器：</h4>\n<p>docker rm 不能删除运行中的容器，除非添加 -f 参数</p>\n<h4 id=\"进入容器\"><a class=\"markdownIt-Anchor\" href=\"#进入容器\">#</a> 进入容器：</h4>\n<p>命令是 docker exec -it [容器名] [要执行的命令] exec 命令可以进入容器修改文件，但是在容器内修改文件是不推荐的</p>\n<p>退出容器：exit ctrl + p +q</p>\n<p>docker 容器 redis 设置</p>\n<p>启动 redis 命令:docker run --name myredis -p 6379:6379 -d redis --requirepass youpassword<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220636.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220639.jpg\" alt=\"image.png\"> 进入容器 docker exec -it myredis bash<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220641.jpg\" alt=\"image.png\"> 执行 redis-cli 命令客户端命令 redis-cli</p>\n<p>认证密码：auth  yourpassword<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220644.jpg\" alt=\"image.png\"> 即可进行正常在 redis 中的操作。可查看 redis 密码：config get requirepass<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220646.jpg\" alt=\"image.png\"> 但是这样我们本机还是服务访问 docker 上的 redis 的，因为 redis 的配置文件中配置只有本地地址才能访问的，所以我们还需配置一波。在 docker 进行配置的 redis 会有些许麻烦：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220649.jpg\" alt=\"image.png\"> 接下来，我们学习了数据卷之后再来配置一波 redis:</p>\n<h3 id=\"数据卷\"><a class=\"markdownIt-Anchor\" href=\"#数据卷\">#</a> 数据卷</h3>\n<p>数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220651.jpg\" alt=\"image.png\"></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220654.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220656.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220658.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220701.jpg\" alt=\"image.png\"></p>\n<p>有关 nacos 的配置，这篇文章讲的很详细：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lsdmppYWxlL2FydGljbGUvZGV0YWlscy8xMjk0MTc3Njg=\">Docker 启动安装 nacos（详情讲解，全网最细）_docker 启动 nacos_Color L 的博客 - CSDN 博客</span></p>\n<h2 id=\"三-dockerfile自定义镜像\"><a class=\"markdownIt-Anchor\" href=\"#三-dockerfile自定义镜像\">#</a> 三、Dockerfile 自定义镜像</h2>\n<h2 id=\"四-docker-compose\"><a class=\"markdownIt-Anchor\" href=\"#四-docker-compose\">#</a> 四、Docker-Compose</h2>\n<h2 id=\"五-docker镜像仓库\"><a class=\"markdownIt-Anchor\" href=\"#五-docker镜像仓库\">#</a> 五、Docker 镜像仓库</h2>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/",
            "title": "Eureka注册中心",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<p>原来的远程调用出现的问题：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Order</span> <span class=\"token function\">queryOrderById</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> orderId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token comment\">// 1. 查询订单</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">Order</span> order <span class=\"token operator\">=</span> orderMapper<span class=\"token punctuation\">.</span><span class=\"token function\">findById</span><span class=\"token punctuation\">(</span>orderId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 2. 利用 RestTemplate 发送 http 请求，查询用户信息</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 2.1 设置 url 地址</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">String</span> url <span class=\"token operator\">=</span> <span class=\"token string\">\"http://localhost:9091/user/\"</span><span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span><span class=\"token function\">getUserId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">// 2.2 发送 Http 请求，实现远程调用</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 2.3 封装 user 到 Order 中</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        order<span class=\"token punctuation\">.</span><span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">// 4. 返回</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>每次的服务地址端口会都是相同的，但是如果以后我们使用集群的话，这样就会产生问题。如果有多个服务提供者，消费者该如何选择？消费者如何得知服务提供者的健康状况？<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220703.jpg\" alt=\"image.png\"></p>\n<h2 id=\"eureka详解\"><a class=\"markdownIt-Anchor\" href=\"#eureka详解\">#</a> Eureka 详解</h2>\n<p>eurekaService: 服务端，注册中心</p>\n<ul>\n<li>记录服务信息</li>\n<li>心跳监控</li>\n</ul>\n<p>eurekaClient: 客户端</p>\n<ul>\n<li>Provider: 服务提供者，例如上图中 user-service\n<ul>\n<li>注册自己的信息到 EurekaService</li>\n<li>每隔 30 秒向 EurekaService 发送心跳</li>\n</ul>\n</li>\n<li>consumer: 服务消费者，例如上图中 order-service\n<ul>\n<li>根据服务名称从 EurekaService 拉取服务列表</li>\n<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>\n</ul>\n</li>\n</ul>\n<p>搭建 EurekaService 环境 1、创建项目引入依赖</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>dependencies<span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>dependency<span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cloud<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>spring<span class=\"token operator\">-</span>cloud<span class=\"token operator\">-</span>starter<span class=\"token operator\">-</span>netflix<span class=\"token operator\">-</span>eureka<span class=\"token operator\">-</span>server<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependency<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependencies<span class=\"token operator\">></span></pre></td></tr></table></figure><p>2、编写启动类，添加 **@EnableEurekaService** 注解</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@EnableEurekaServer</span> <span class=\"token comment\">// 开启 Eureka 服务</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootApplication</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">EurekaApplication</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EurekaApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>3、添加 application.yml 文件，编写配置</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">9092</span> <span class=\"token comment\"># 服务端口</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#  服务注册</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> eurekaserver</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token key atrule\">eureka</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token key atrule\">client</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token key atrule\">service-url</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token key atrule\">defaultZone</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span>9092/eureka/</pre></td></tr></table></figure><h2 id=\"报错\"><a class=\"markdownIt-Anchor\" href=\"#报错\">#</a> 报错</h2>\n<p>同样的配置，这样我们启动时会报错，报错原因是连接被拒绝。** 原因：是因为 eureka 默认会去检索服务，当我们只写了这么一个注册中心（eureka）而没有其他服务的时候，它去检索服务就会出现上述错误。所以需要添加配置 fetch-registry: false。当我们配置多个服务时，我们要去掉这个。**<strong> 我们点击</strong><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220706.jpg\" alt=\"image.png\"> 跳转的界面是：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220708.jpg\" alt=\"image.png\"> 这里显示注册到 Eureka 中的实例。服务注册：1、创建项目引入依赖</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>注册eureka的客户端<span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>dependency<span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cloud<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>spring<span class=\"token operator\">-</span>cloud<span class=\"token operator\">-</span>starter<span class=\"token operator\">-</span>netflix<span class=\"token operator\">-</span>eureka<span class=\"token operator\">-</span>client<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependency<span class=\"token operator\">></span></pre></td></tr></table></figure><p>2、在 application.yml 中配置 eureka 地址 (注意端口号与服务端端口号一致)</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">eureka</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">client</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token key atrule\">service-url</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      <span class=\"token key atrule\">defaultZone</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span>9092/eureka/</pre></td></tr></table></figure><p>服务发现：我们只需在 RestTempleate 的 bean 上加上负载均衡注解即可完成负载均衡</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@LoadBalanced</span> <span class=\"token comment\">// 添加负载均衡注解</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">RestTemplate</span> <span class=\"token function\">restTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在拉取时，我们的 url 不能写死，我们需要写服务名称即可<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220710.jpg\" alt=\"image.png\"> 这样我们配置多个服务时，我们依靠 Eureka 注册中心就能拉取相应的服务了</p>\n<p>总结一波：1、搭建 EurekaServer</p>\n<ul>\n<li>引入 eureka-server 依赖</li>\n<li>添加 @EnableEurekaServer 注解</li>\n<li>在 application.yml 中配置 eureka 地址</li>\n</ul>\n<p>2、服务注册</p>\n<ul>\n<li>引入 eureka-client 依赖</li>\n<li>在 application.yml 中配置 eureka 地址</li>\n</ul>\n<p>3、服务发现</p>\n<ul>\n<li>引入 eureka-client 依赖</li>\n<li>在 application.yml 中配置 eureka 地址</li>\n<li>给 RestTemplate 添加 @LoadBalanced 注解</li>\n<li>给服务提供者的服务名称远程调用</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Gateway%E7%BD%91%E5%85%B3/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Gateway%E7%BD%91%E5%85%B3/",
            "title": "Gateway网关",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"一-为什么需要网关\"><a class=\"markdownIt-Anchor\" href=\"#一-为什么需要网关\">#</a> 一、为什么需要网关</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220713.jpg\" alt=\"image.png\"> 在 SpringCloud 中网关的实现包括两种：</p>\n<ul>\n<li>gateway</li>\n<li>zuul</li>\n</ul>\n<p>Zuul 是基于 Servlet 的实现，属于阻塞式编程。而 SpringCloudGateway 则是基于 Spring5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。</p>\n<p>总结：网关的作用：</p>\n<ul>\n<li>对用户请求做身份认证、权限校验</li>\n<li>将用户请求路由到微服务，并实现负载均衡</li>\n<li>对用户请求做限流</li>\n</ul>\n<h2 id=\"二-gateway快速入门\"><a class=\"markdownIt-Anchor\" href=\"#二-gateway快速入门\">#</a> 二、gateway 快速入门</h2>\n<p>网关配置通常是一个统一的模块</p>\n<h3 id=\"搭建网关服务的步骤如下\"><a class=\"markdownIt-Anchor\" href=\"#搭建网关服务的步骤如下\">#</a> 搭建网关服务的步骤如下：</h3>\n<h4 id=\"1-创建新的module引入springcloudgateway的依赖和nacos的服务发现依赖\"><a class=\"markdownIt-Anchor\" href=\"#1-创建新的module引入springcloudgateway的依赖和nacos的服务发现依赖\">#</a> 1、创建新的 module，引入 SpringCloudGateway 的依赖和 nacos 的服务发现依赖：</h4>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">&lt;!--nacos 的服务注册发现依赖 --></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.alibaba.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">&lt;!-- 网关依赖 --></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-cloud-starter-gateway<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h4 id=\"2-编写路由配置以及nacos地址\"><a class=\"markdownIt-Anchor\" href=\"#2-编写路由配置以及nacos地址\">#</a> 2、编写路由配置以及 nacos 地址</h4>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1313</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> gateway</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token comment\"># 配置 nacos</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c  <span class=\"token comment\"># dev 环境</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token key atrule\">gateway</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token key atrule\">routes</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 配置网关路由</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>         <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> user<span class=\"token punctuation\">-</span>service  <span class=\"token comment\"># 路由 id，自定义，只要唯一即可</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>           <span class=\"token comment\"># uri: http://127.0.0.1:8081 # 路由的目标地址 http 就是固定地址</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>           <span class=\"token key atrule\">uri</span><span class=\"token punctuation\">:</span> lb<span class=\"token punctuation\">:</span>//userservice <span class=\"token comment\"># 路由的目标地址 lb 就是负载均衡，后面跟服务名称</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>           <span class=\"token key atrule\">predicates</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 路由断言，也就是判断请求是否符合路由规则的条件</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>             <span class=\"token punctuation\">-</span> Path=/user/<span class=\"token important\">**</span>  <span class=\"token comment\"># 这个是按照路径匹配，只要以 /user/ 开头就符合要求</span></pre></td></tr></table></figure><p>我们在 postman 中访问当前网关端口，只要与网关路由配置断言匹配即可访问。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220716.jpg\" alt=\"image.png\"> 执行流程如下：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220718.jpg\" alt=\"image.png\"></p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结：</h3>\n<h4 id=\"网关搭建步骤\"><a class=\"markdownIt-Anchor\" href=\"#网关搭建步骤\">#</a> 网关搭建步骤：</h4>\n<p>1、创建项目，引入 nacos 服务发现和 gateway 依赖 2、配置 application.yml，包括服务基本信息、nacos 地址、路由</p>\n<h4 id=\"路由配置包括\"><a class=\"markdownIt-Anchor\" href=\"#路由配置包括\">#</a> 路由配置包括：</h4>\n<p>1、路由 id：路由的唯一标示 2、路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡 3、路由断言（predicates）：判断路由的规则，4、路由过滤器（filters）：对请求或响应做处理</p>\n<h2 id=\"三-断言工厂\"><a class=\"markdownIt-Anchor\" href=\"#三-断言工厂\">#</a> 三、断言工厂</h2>\n<h3 id=\"网关路由可以配置的内容包括\"><a class=\"markdownIt-Anchor\" href=\"#网关路由可以配置的内容包括\">#</a> 网关路由可以配置的内容包括：</h3>\n<ul>\n<li>路由 id：路由唯一标示</li>\n<li>uri：路由目的地，支持 lb 和 http 两种</li>\n<li>predicates：路由断言，判断请求是否符合要求，符合则转发到路由目的地</li>\n<li>filters：路由过滤器，处理请求或响应</li>\n</ul>\n<h3 id=\"路由断言工厂route-predicate-factory\"><a class=\"markdownIt-Anchor\" href=\"#路由断言工厂route-predicate-factory\">#</a> 路由断言工厂 Route Predicate Factory</h3>\n<p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件例如 Path=/user/** 是按照路径匹配，这个规则是由 org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory 类来处理的像这样的断言工厂在 SpringCloudGateway 还有十几个<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220720.jpg\" alt=\"image.png\"> 总结：PredicateFactory 的作用是什么？</p>\n<ul>\n<li>读取用户定义的断言条件，对请求做出判断</li>\n</ul>\n<p>Path=/user/** 是什么含义？</p>\n<ul>\n<li>路径是以 /user 开头的就认为是符合的</li>\n</ul>\n<h2 id=\"四-过滤器工厂\"><a class=\"markdownIt-Anchor\" href=\"#四-过滤器工厂\">#</a> 四、过滤器工厂</h2>\n<p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220723.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220726.jpg\" alt=\"image.png\"> 如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：(注意 default-filters)</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1313</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> gateway</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token comment\"># 配置 nacos</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c  <span class=\"token comment\"># dev 环境</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token key atrule\">gateway</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token key atrule\">routes</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 配置网关路由</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>         <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> user<span class=\"token punctuation\">-</span>service  <span class=\"token comment\"># 路由 id，自定义，只要唯一即可</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>           <span class=\"token comment\"># uri: http://127.0.0.1:8081 # 路由的目标地址 http 就是固定地址</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>           <span class=\"token key atrule\">uri</span><span class=\"token punctuation\">:</span> lb<span class=\"token punctuation\">:</span>//userservice <span class=\"token comment\"># 路由的目标地址 lb 就是负载均衡，后面跟服务名称</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>           <span class=\"token key atrule\">predicates</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 路由断言，也就是判断请求是否符合路由规则的条件</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>             <span class=\"token punctuation\">-</span> Path=/user/<span class=\"token important\">**</span>  <span class=\"token comment\"># 这个是按照路径匹配，只要以 /user/ 开头就符合要求</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>      <span class=\"token key atrule\">default-filters</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 默认过滤器，会对所有的路由请求都生效</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">-</span> AddRequestHeader= Truth<span class=\"token punctuation\">,</span> Itcast is freaking awesome<span class=\"token tag\">!</span> <span class=\"token comment\"># 添加请求头</span></pre></td></tr></table></figure><h3 id=\"总结-2\"><a class=\"markdownIt-Anchor\" href=\"#总结-2\">#</a> 总结：</h3>\n<h4 id=\"过滤器的作用是什么\"><a class=\"markdownIt-Anchor\" href=\"#过滤器的作用是什么\">#</a> 过滤器的作用是什么？</h4>\n<p>对路由的请求或响应做加工处理，比如添加请求头配置在路由下的过滤器只对当前路由的请求生效</p>\n<h3 id=\"defaultfilters的作用是什么\"><a class=\"markdownIt-Anchor\" href=\"#defaultfilters的作用是什么\">#</a> defaultFilters 的作用是什么？</h3>\n<p>对所有路由都生效的过滤器</p>\n<h2 id=\"五-全局过滤器\"><a class=\"markdownIt-Anchor\" href=\"#五-全局过滤器\">#</a> 五、全局过滤器</h2>\n<p>全局过滤器 GlobalFilter 全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GatewayFilter 通过配置定义，处理逻辑是固定的。而 GlobalFilter 的逻辑需要自己写代码实现。定义方式是实现 GlobalFilter 接口。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AuthorizeFilter</span>  <span class=\"token keyword\">implements</span> <span class=\"token class-name\">GatewayFilter</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Mono</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Void</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ServerWebExchange</span> exchange<span class=\"token punctuation\">,</span> <span class=\"token class-name\">GatewayFilterChain</span> chain<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        方法体内，可做用户认证操作</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>         */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"总结-3\"><a class=\"markdownIt-Anchor\" href=\"#总结-3\">#</a> 总结：</h3>\n<h4 id=\"全局过滤器的作用是什么\"><a class=\"markdownIt-Anchor\" href=\"#全局过滤器的作用是什么\">#</a> 全局过滤器的作用是什么？</h4>\n<p>对所有路由都生效的过滤器，并且可以自定义处理逻辑</p>\n<h4 id=\"实现全局过滤器的步骤\"><a class=\"markdownIt-Anchor\" href=\"#实现全局过滤器的步骤\">#</a> 实现全局过滤器的步骤？</h4>\n<p>实现 GlobalFilter 接口添加 @Order 注解或实现 Ordered 接口编写处理逻辑</p>\n<h3 id=\"过滤器执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#过滤器执行顺序\">#</a> 过滤器执行顺序</h3>\n<p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter 请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220728.jpg\" alt=\"image.png\"> 过滤器执行顺序每一个过滤器都必须指定一个 int 类型的 order 值，order 值越小，优先级越高，执行顺序越靠前。GlobalFilter 通过实现 Ordered 接口，或者添加 @Order 注解来指定 order 值，由我们自己指定路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</p>\n<h2 id=\"六-跨域问题\"><a class=\"markdownIt-Anchor\" href=\"#六-跨域问题\">#</a> 六、跨域问题</h2>\n<p>跨域：域名不一致就是跨域，主要包括：</p>\n<ul>\n<li>域名不同： <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy50YW9iYW8uY29t\">www.taobao.com</span> 和 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy50YW9iYW8ub3Jn\">www.taobao.org</span> 和 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qZC5jb20=\">www.jd.com</span> 和 miaosha.jd.com 域名相同，</li>\n<li>端口不同：localhost:8080 和 localhost8081</li>\n<li>跨域问题：浏览器禁止请求的发起者与服务端发生跨域 ajax 请求，请求被浏览器拦截的问题解决方案：CORS</li>\n</ul>\n<p>网关处理跨域采用的同样是 CORS 方案，并且只需要简单配置即可实现：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1313</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> gateway</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token comment\"># 配置 nacos</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c  <span class=\"token comment\"># dev 环境</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token key atrule\">gateway</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      <span class=\"token comment\"># 配置跨域请求</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>      <span class=\"token key atrule\">globalcors</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 全局的跨域处理</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token key atrule\">add-to-simple-url-handler-mapping</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>  <span class=\"token comment\"># 解决 options 请求被拦截问题</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        cors<span class=\"token punctuation\">-</span>configurations<span class=\"token punctuation\">:</span><span class=\"token key atrule\">'[/**]'</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>          <span class=\"token key atrule\">allowedOrigins</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 允许哪些网址的跨域请求</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token punctuation\">-</span> <span class=\"token string\">'http://loaclhost:8090'</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token punctuation\">-</span> <span class=\"token string\">'http://loaclhost:8090'</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>          <span class=\"token key atrule\">allowedMethods</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 允许跨域 ajax 的请求方式</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token punctuation\">-</span> <span class=\"token string\">\"GET\"</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token punctuation\">-</span> <span class=\"token string\">\"POST\"</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token punctuation\">-</span> <span class=\"token string\">\"DELETE\"</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token punctuation\">-</span> <span class=\"token string\">\"OPTIONS\"</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>          <span class=\"token key atrule\">allowedHeaders</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"*\"</span>   <span class=\"token comment\"># 允许在请求头中携带的头部信息</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>          <span class=\"token key atrule\">allowCredentials</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>  <span class=\"token comment\"># 是否允许携带 cookie</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>          <span class=\"token key atrule\">maxAge</span><span class=\"token punctuation\">:</span> <span class=\"token number\">360000</span>  <span class=\"token comment\"># 这次跨域检测的有效期</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>      <span class=\"token key atrule\">routes</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 配置网关路由</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>         <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> user<span class=\"token punctuation\">-</span>service  <span class=\"token comment\"># 路由 id，自定义，只要唯一即可</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>           <span class=\"token comment\"># uri: http://127.0.0.1:8081 # 路由的目标地址 http 就是固定地址</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>           <span class=\"token key atrule\">uri</span><span class=\"token punctuation\">:</span> lb<span class=\"token punctuation\">:</span>//userservice <span class=\"token comment\"># 路由的目标地址 lb 就是负载均衡，后面跟服务名称</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>           <span class=\"token key atrule\">predicates</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 路由断言，也就是判断请求是否符合路由规则的条件</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>             <span class=\"token punctuation\">-</span> Path=/user/<span class=\"token important\">**</span>  <span class=\"token comment\"># 这个是按照路径匹配，只要以 /user/ 开头就符合要求</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>      <span class=\"token key atrule\">default-filters</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 默认过滤器，会对所有的路由请求都生效</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token punctuation\">-</span> AddRequestHeader= Truth<span class=\"token punctuation\">,</span> Itcast is freaking awesome<span class=\"token tag\">!</span> <span class=\"token comment\"># 添加请求头</span></pre></td></tr></table></figure><h3 id=\"cors跨域要配置的参数包括哪几个\"><a class=\"markdownIt-Anchor\" href=\"#cors跨域要配置的参数包括哪几个\">#</a> CORS 跨域要配置的参数包括哪几个？</h3>\n<p>允许哪些域名跨域？允许哪些请求头？允许哪些请求方式？是否允许使用 cookie？有效期是多久？</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/",
            "title": "Nacos注册中心",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"一-配置\"><a class=\"markdownIt-Anchor\" href=\"#一-配置\">#</a> 一、配置</h2>\n<h3 id=\"下载安装\"><a class=\"markdownIt-Anchor\" href=\"#下载安装\">#</a> 下载安装</h3>\n<p>自我感觉哈，Nacos 注册中心的使用比 Eureka 注册中心要简单一些。简要说明一下 Nacos 注册中心的配置以及使用：首先需要安装 Nacos，这里为了方便使用，在本地安装了 Nacos。去 Nacos 官方网址去下载 Nacos<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220738.jpg\" alt=\"image.png\">window 下载 zip 版本，linux 下载 tar 版本。当前推荐下载安装 2.1.1 稳点版本\t。（注意路径不能存在中文）下载解压后<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220740.jpg\" alt=\"image.png\"> 在 conf 目录下中找到 application.properties 可配置端口号，默认端口号为 8848 然后打开 bin 目录，bin 目录下为执行脚本，在当前目录下执行 cmd 打开命令行窗口，执行 startup.cmd -m standlone 可单模式下启动，集群配置后面再搞吧。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220743.jpg\" alt=\"image.png\"> 随后我们可以访问给的网址，我们输入账号密码即可登录可视化工具，账号密码初始值都为：nacos。</p>\n<h3 id=\"服务配置\"><a class=\"markdownIt-Anchor\" href=\"#服务配置\">#</a> 服务配置</h3>\n<p>我们在 idea 中继续来配置服务。我们需要在父工程中引入管理依赖：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>nacos管理依赖<span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>dependency<span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>com<span class=\"token punctuation\">.</span>alibaba<span class=\"token punctuation\">.</span>cloud<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>spring<span class=\"token operator\">-</span>cloud<span class=\"token operator\">-</span>alibaba<span class=\"token operator\">-</span>dependencies<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>version<span class=\"token punctuation\">></span></span><span class=\"token number\">2.2</span><span class=\"token number\">.5</span><span class=\"token punctuation\">.</span><span class=\"token constant\">RELEASE</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>version<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>type<span class=\"token punctuation\">></span></span>pom<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>type<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>scope<span class=\"token punctuation\">></span></span><span class=\"token keyword\">import</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>scope<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependency<span class=\"token operator\">></span></pre></td></tr></table></figure><p>然后再其服务模块中引入：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>dependency<span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>groupId<span class=\"token punctuation\">></span></span>com<span class=\"token punctuation\">.</span>alibaba<span class=\"token punctuation\">.</span>cloud<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>artifactId<span class=\"token punctuation\">></span></span>spring<span class=\"token operator\">-</span>cloud<span class=\"token operator\">-</span>starter<span class=\"token operator\">-</span>alibaba<span class=\"token operator\">-</span>nacos<span class=\"token operator\">-</span>discovery<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependency<span class=\"token operator\">></span></pre></td></tr></table></figure><p>之后，我们再服务模块的 application.yml 文件中配置：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 配置 nacos</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span> <span class=\"token comment\"># nacos 服务地址，其实默认的也是 localhost:8848</span></pre></td></tr></table></figure><p>启动项目，我们打开 nacos 可视化界面中，查看服务：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220745.jpg\" alt=\"image.png\"> 可见，我们的配置成功了。</p>\n<h2 id=\"二-nacos服务分级存储模型\"><a class=\"markdownIt-Anchor\" href=\"#二-nacos服务分级存储模型\">#</a> 二、Nacos 服务分级存储模型</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>一个服务可包含多个实例服务 --&gt; 集群  --&gt; 实例<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220747.jpg\" alt=\"image.png\"> 服务跨集群调用问题服务调用尽可能选择本地集群的服务，跨集群调用延迟较高本地集群不可访问时，再去访问其它集群。因为本地访问速度相对较快。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220750.jpg\" alt=\"image.png\"></p>\n<h3 id=\"服务集群配置\"><a class=\"markdownIt-Anchor\" href=\"#服务集群配置\">#</a> 服务集群配置：</h3>\n<p>1、修改 application.yml，添加如下内容：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 配置 nacos</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span> <span class=\"token comment\"># nacos 服务地址</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token key atrule\">cluster-name</span><span class=\"token punctuation\">:</span> JS <span class=\"token comment\"># 配置集群地址 (可自定义)</span></pre></td></tr></table></figure><p>2、可在 nacos 控制台查看<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220753.jpg\" alt=\"image.png\"></p>\n<p>Nacos 服务分级存储模型</p>\n<ul>\n<li>一级是服务，例如 userservice</li>\n<li>二级是集群，例如杭州或上海</li>\n<li>三级是实例，例如杭州机房的某台部署了 userservice 的服务器</li>\n</ul>\n<p>如何设置实例的集群属性</p>\n<ul>\n<li>修改 application.yml 文件，添加 spring.cloud.nacos.discovery.cluster-name 属性即可</li>\n</ul>\n<h3 id=\"服务集群属性配置\"><a class=\"markdownIt-Anchor\" href=\"#服务集群属性配置\">#</a> 服务集群属性配置：</h3>\n<p>我们可以在集群为 XZ 的配置多个实例，在集群为 LYG 的配置一个实例作为服务者，我们在一个消费者，当前消费者在 LYG, 我们如何能做到让消费者访问服务优先访问 LYG 集群内的实例而不访问集群为 XZ 的实例呢？这时我们就需要在消费者中配置 Nacos 的服务访问规则。（设置负载均衡的 IRule 为 NacosRule，这个规则优先会寻找与自己同集群的服务）</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#  配置服务访问规则</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">userservice</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 消费者服务</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">ribbon</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">NFLoadBalancerRuleClassName</span><span class=\"token punctuation\">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule</pre></td></tr></table></figure><p>这里的配置并非全局配置，只针对 userservice 服务有效，访问的是同一个集群下的实例，但如果当前集群下有多个实例，则按照随机的方式来访问。如果当前集群下的服务全部宕机，当前消费者还是得访问其他集群下的服务，但是这样会报一个警告。为跨集群访问，以便运维人员来重启服务。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220756.jpg\" alt=\"image.png\"></p>\n<h3 id=\"nacosrule负载均衡策略\"><a class=\"markdownIt-Anchor\" href=\"#nacosrule负载均衡策略\">#</a> NacosRule 负载均衡策略</h3>\n<ul>\n<li>优先选择同集群服务实例列表</li>\n<li>本地集群找不到提供者，才去其它集群寻找，并且会报警告</li>\n<li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li>\n</ul>\n<h2 id=\"三-naco权重负载均衡\"><a class=\"markdownIt-Anchor\" href=\"#三-naco权重负载均衡\">#</a> 三、Naco 权重负载均衡</h2>\n<p>实际部署中会出现这样的场景：服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求 Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高。那么，我们如何来配置权重呢？简单的是，这一步根部不需要写代码就可以来实现，因为运维人员他们可以在 nacos 控制台来进行配置权重。</p>\n<h3 id=\"配置\"><a class=\"markdownIt-Anchor\" href=\"#配置\">#</a> 配置</h3>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220758.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220800.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220804.jpg\" alt=\"image.png\"> 权重范围是  0~1 ，权重为 0 的，就相当于等于停机了，用户请求无法访问到当前服务上来，配置为 1，使用请求都能打过来，相较于其他的服务，1 是最大的才能满足所以请求都打到本台服务上来。</p>\n<h3 id=\"总结实例的权重控制\"><a class=\"markdownIt-Anchor\" href=\"#总结实例的权重控制\">#</a> 总结：（实例的权重控制）</h3>\n<ul>\n<li>Nacos 控制台可以设置实例的权重值，0~1 之间</li>\n<li>同集群内的多个实例，权重越高被访问的频率越高</li>\n<li>权重设置为 0 则完全不会被访问</li>\n</ul>\n<h2 id=\"四-环境隔离-namespace\"><a class=\"markdownIt-Anchor\" href=\"#四-环境隔离-namespace\">#</a> 四、环境隔离 - namespace</h2>\n<h3 id=\"配置-2\"><a class=\"markdownIt-Anchor\" href=\"#配置-2\">#</a> 配置</h3>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220806.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220809.jpg\" alt=\"image.png\"> 复制命名空间的 ID<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220811.jpg\" alt=\"image.png\"> 在代码中配置：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>      <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span> <span class=\"token comment\"># nacos 服务地址</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>          <span class=\"token key atrule\">cluster-name</span><span class=\"token punctuation\">:</span> XZ <span class=\"token comment\"># 配置集群名称</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>          <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c  <span class=\"token comment\"># dev 环境</span></pre></td></tr></table></figure><p>重启服务后，观察控制台：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220813.jpg\" alt=\"image.png\"> 可发现在 dev 命名空间中存在该服务了。继续访问的话，报错 500<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220815.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220817.jpg\" alt=\"image.png\"> 报错为：没有可用服务，相当于两个服务被隔离起来，要相访问必须在同一个命名空间下。</p>\n<h3 id=\"总结nacos环境隔离\"><a class=\"markdownIt-Anchor\" href=\"#总结nacos环境隔离\">#</a> 总结：（Nacos 环境隔离）</h3>\n<ul>\n<li>每个 namespace 都有唯一 id</li>\n<li>服务设置 namespace 时要写 id 而不是名称</li>\n<li>不同 namespace 下的服务互相不可见</li>\n</ul>\n<h2 id=\"nacos和eureka的区别以及共同点\"><a class=\"markdownIt-Anchor\" href=\"#nacos和eureka的区别以及共同点\">#</a> Nacos 和 Eureka 的区别以及共同点</h2>\n<h3 id=\"nacos与eureka的共同点\"><a class=\"markdownIt-Anchor\" href=\"#nacos与eureka的共同点\">#</a> Nacos 与 eureka 的共同点</h3>\n<ul>\n<li>都支持服务注册和服务拉取</li>\n<li>都支持服务提供者心跳方式做健康检测</li>\n</ul>\n<h3 id=\"nacos与eureka的区别\"><a class=\"markdownIt-Anchor\" href=\"#nacos与eureka的区别\">#</a> Nacos 与 Eureka 的区别</h3>\n<ul>\n<li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>\n<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>\n<li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</li>\n<li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka 采用 AP 方式</li>\n</ul>\n<p>Nacos 配置非临时实例：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t\t<span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t\t\t <span class=\"token key atrule\">ephemeral</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span> <span class=\"token comment\"># 设置为非临时实例</span></pre></td></tr></table></figure><p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220819.jpg\" alt=\"image.png\"></p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/",
            "title": "Ribbon负载均衡",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"为何ribbon可以做到负载均衡原理\"><a class=\"markdownIt-Anchor\" href=\"#为何ribbon可以做到负载均衡原理\">#</a> 为何 Ribbon 可以做到负载均衡（原理）？</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220847.jpg\" alt=\"image.png\"> 发送请求：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220850.jpg\" alt=\"image.png\"> 继续 debug 会进入到 LoadBalancerInterceptor 拦截器中，我们会发现在拦截请求中实质上是获取了 URI，获取了主机名称，后将主机名称传给了 RibbonLoadBalanceIacerClient, 负载均衡客户端会继续执行<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220852.jpg\" alt=\"image.png\"> 之后进入到 execute 方法中，通过服务 ID，会在 Eureka 中找到 ID 相同的服务封装成 List。（RibbonLoadBalancerClient）getLoadBalancer 是在根据服务名称找 Eureka 的服务名称来拉取服务的，继续进入 getServer 方法中，<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220855.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220859.jpg\" alt=\"image.png\"> 到这里一步，我们已经拉取到服务列表了，这样我们就可以开始做负载均衡了，我们可以看到使用了一个叫 rule 的 choose 方法来选择<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220901.jpg\" alt=\"image.png\">rule 是什么呢？<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220903.jpg\" alt=\"image.png\"> 通过 IRule 来决定选择负载均衡<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220906.jpg\" alt=\"image.png\"> 执行完成 rule 的 choose 之后，我们就找到了这个服务的 ip 和端口号了<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220908.jpg\" alt=\"image.png\"></p>\n<p>实质上，我们的请求会被一个叫做 LoadBalanceInterceptor 负载均衡拦截器拦截，后将服务的名称交给 RibbonLoadBalcaneClient，然后将 url 的服务 ID 交给 DynamicServiceListLoadBalance 去拉取服务信息，然后通过 IRule 来做负载均衡。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220910.jpg\" alt=\"image.png\"></p>\n<h2 id=\"配置ribbon负载均衡\"><a class=\"markdownIt-Anchor\" href=\"#配置ribbon负载均衡\">#</a> 配置 Ribbon 负载均衡</h2>\n<h3 id=\"ribbon负载均衡策略\"><a class=\"markdownIt-Anchor\" href=\"#ribbon负载均衡策略\">#</a> Ribbon 负载均衡策略</h3>\n<p>Ribbon 的负载均衡规则是一个叫做 IRule 的接口来定义的，每一个子接口都是一种规则：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220913.jpg\" alt=\"image.png\"></p>\n<h3 id=\"负载均衡策略\"><a class=\"markdownIt-Anchor\" href=\"#负载均衡策略\">#</a> 负载均衡策略</h3>\n<table>\n<thead>\n<tr>\n<th><strong>内置负载均衡规则类</strong></th>\n<th><strong>规则描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RoundRobinRule</td>\n<td>简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。</td>\n</tr>\n<tr>\n<td>AvailabilityFilteringRule</td>\n<td>对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为 “短路” 状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit 属性进行配置。</td>\n</tr>\n<tr>\n<td>WeightedResponseTimeRule</td>\n<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>\n</tr>\n<tr>\n<td>ZoneAvoidanceRule</td>\n<td>以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。</td>\n</tr>\n<tr>\n<td>BestAvailableRule</td>\n<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>\n</tr>\n<tr>\n<td>RandomRule</td>\n<td>随机选择一个可用的服务器。</td>\n</tr>\n<tr>\n<td>RetryRule</td>\n<td>重试机制的选择逻辑</td>\n</tr>\n</tbody>\n</table>\n<p><strong>这样我们完全可以自己配置一个 bean 来实现自定义负载均衡策略。</strong></p>\n<h3 id=\"配置方式\"><a class=\"markdownIt-Anchor\" href=\"#配置方式\">#</a> 配置方式：</h3>\n<h4 id=\"全局配置\"><a class=\"markdownIt-Anchor\" href=\"#全局配置\">#</a> 全局配置：</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">IRule</span> <span class=\"token function\">randomRule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomRule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这样配置，会导致我们选择任何服务者都是使用我们自己配置的 RandomRule 方式来选择服务的。即选择调用任何服务接口都是随机的。配置文件方式（非全局，需自己选择）：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">userservice</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 服务名称</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token key atrule\">ribbon</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token key atrule\">NFLoadBalancerRuleClassName</span><span class=\"token punctuation\">:</span> com.netflix.loadbalancer.RandomRule  <span class=\"token comment\"># 负载均衡规则</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 可配置其他的服务负载均衡规则</span></pre></td></tr></table></figure><p>小提示：我们自己手动配置的 bean 会注入到 Spring 容器中，这样在给其他类添加属性 bean 时会将 Spring 容器中的 bean 注入到该对象上去。所以我们的配置的 bean 才会生效，走我们自己配置信息。</p>\n<h2 id=\"ribbon默认是懒加载模式\"><a class=\"markdownIt-Anchor\" href=\"#ribbon默认是懒加载模式\">#</a> Ribbon 默认是懒加载模式：</h2>\n<p>默认第一次请求的时候，才会去创建 LoadBalanceClient, 请求时间会很长。</p>\n<h3 id=\"饥饿加载\"><a class=\"markdownIt-Anchor\" href=\"#饥饿加载\">#</a> 饥饿加载</h3>\n<p>我们配置饥饿加载会在项目启动时创建，降低第一次访问的耗时，我们可以通过下面的配置来开启饥饿加载：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ribbon<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  eager<span class=\"token operator\">-</span>load<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    enabled<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> # 开启饥饿加载</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    clients<span class=\"token operator\">:</span> userservice  # 我们针对那个服务做的饥饿加载</pre></td></tr></table></figure><figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">ribbon</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">eager-load</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># 开启饥饿加载</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">clients</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 配置针对多个</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      <span class=\"token punctuation\">-</span> userservice</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      <span class=\"token punctuation\">-</span> xxservice</pre></td></tr></table></figure><h2 id=\"稍作总结\"><a class=\"markdownIt-Anchor\" href=\"#稍作总结\">#</a> 稍作总结：</h2>\n<p>1、Ribbon 负载均衡规则</p>\n<ul>\n<li>默认接口是 IRule</li>\n<li>默认选择是 ZoneAvoidanceRule, 根据 zone 选择服务列表，然后轮询</li>\n</ul>\n<p>2、负载均衡自定义方式</p>\n<ul>\n<li>代码方式：配置灵活，但修改时需要重新打包发布</li>\n<li>配置方式：直观，方便，无需重新打包发布，但是无法做到全局配置</li>\n</ul>\n<p>3、饥饿加载</p>\n<ul>\n<li>开启饥饿加载</li>\n<li>指定饥饿加载的微服务名称</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Nacos%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Nacos%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/",
            "title": "Nacos配置管理",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"一-统一配置管理\"><a class=\"markdownIt-Anchor\" href=\"#一-统一配置管理\">#</a> 一、统一配置管理</h2>\n<p>配置更新热更新<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220821.jpg\" alt=\"image.png\"></p>\n<h4 id=\"在nacos中添加配置信息\"><a class=\"markdownIt-Anchor\" href=\"#在nacos中添加配置信息\">#</a> 在 Nacos 中添加配置信息：</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220824.jpg\" alt=\"image.png\"></p>\n<h4 id=\"在弹出的表单中填写配置信息\"><a class=\"markdownIt-Anchor\" href=\"#在弹出的表单中填写配置信息\">#</a> 在弹出的表单中填写配置信息</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220826.jpg\" alt=\"image.png\"> 注意看，我上面的所以配置都是在 dev 环境下的，等会我会出一个错误。继续：原来我们读取配置是这样的：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220828.jpg\" alt=\"image.png\"> 我们加入 nacos 的配置后，配置变成这样的：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220830.jpg\" alt=\"image.png\"> 但是这样我们如何能做到，根本就不知道 nacos 的地址就去读取 nacos 中的配置文件信息呢？这就引出一个新的东西，我是才听说的，所以才说是新的，哈哈哈哈哈，那就是 bootstrap.yml 文件，我们来看一下 bootstarp.yml 与 application.yml 文件的区别。若 application.yml 和 bootstrap.yml 在同一目录下：bootstrap.yml 先加载 application.yml 后加载 bootstrap.yml 用于应用程序上下文的引导阶段。bootstrap.yml 由父 Spring ApplicationContext 加载。所以我们只需在 bootstrap.yml 文件中配置 nacos 地址就可用读取 nacos 配置文件中的信息，然后与本地 application.yml 文件配置文件信息合并，达到动态热更新咯。这波太神奇了。王某人直呼 6666666.<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220832.jpg\" alt=\"image.png\"> 配置完上述内容后，我们进入 idea, 添加配置管理依赖：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">&lt;!--nacos 的配置管理依赖 (配置管理)--></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.alibaba.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-cloud-starter-alibaba-nacos-config<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>在 resource 目录下添加，bootstrap.yml 文件<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220835.jpg\" alt=\"image.png\"> 内容如下；注意删除原本 application.yml 中的 nacos 配置信息</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 服务名称 + 服务地址 + 后缀名  --> nacos 中的配置 dataID</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> userservice</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">profiles</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">active</span><span class=\"token punctuation\">:</span> dev <span class=\"token comment\"># 环境</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c  <span class=\"token comment\"># dev 环境</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>      <span class=\"token key atrule\">config</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token key atrule\">file-extension</span><span class=\"token punctuation\">:</span> yaml <span class=\"token comment\"># 文件后缀名</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre> \t\t\t\t<span class=\"token comment\"># 因为刚才配置的管理命名空间是在 dev 环境下如果不添加这个读取内容会报错。不在同一个空间如何协作呢？</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c</pre></td></tr></table></figure><p>然后我们可以像正常读取配置文件中的内容一样来读取。</p>\n<h3 id=\"二-将配置交给nacos管理的步骤\"><a class=\"markdownIt-Anchor\" href=\"#二-将配置交给nacos管理的步骤\">#</a> 二、将配置交给 Nacos 管理的步骤</h3>\n<ul>\n<li>在 Nacos 中添加配置文件</li>\n<li>在微服务中引入 nacos 的 config 依赖</li>\n<li>在微服务中添加 bootstrap.yml，配置 nacos 地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去 nacos 读取哪个文件</li>\n</ul>\n<p>配置自动刷新 Nacos 中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现：方式一、通过 @Value 注解来实现  ，自动自动刷新使用 @RefreshScope 注解来实现 <img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220837.jpg\" alt=\"image.png\"> 方式二、使用 @ConfigurationProperties 注解<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220839.jpg\" alt=\"image.png\"> 推荐使用方式二。</p>\n<h4 id=\"总结一波nacos配置更改后微服务可以实现热更新\"><a class=\"markdownIt-Anchor\" href=\"#总结一波nacos配置更改后微服务可以实现热更新\">#</a> 总结一波，Nacos 配置更改后，微服务可以实现热更新，</h4>\n<p>方式：</p>\n<ul>\n<li>通过 @Value 注解注入，结合 @RefreshScope 来刷新</li>\n<li>通过 @ConfigurationProperties 注入，自动刷新</li>\n</ul>\n<p>注意事项：不是所有的配置都适合放到配置中心，维护起来比较麻烦建议将一些关键参数，需要运行时调整的参数放到 nacos 配置中心，一般都是自定义配置</p>\n<h2 id=\"三-多环境配置共享\"><a class=\"markdownIt-Anchor\" href=\"#三-多环境配置共享\">#</a> 三、多环境配置共享</h2>\n<p>微服务启动时会从 nacos 读取多个配置文件：[<span class=\"exturl\" data-url=\"aHR0cDovL3NwcmluZy5hcHBsaWNhdGlvbi5uYW1l\">spring.application.name</span>]-[spring.profiles.active].yaml，例如：userservice-dev.yaml [<span class=\"exturl\" data-url=\"aHR0cDovL3NwcmluZy5hcHBsaWNhdGlvbi5uYW1l\">spring.application.name</span>].yaml，例如：userservice.yaml 无论 profile 如何变化，[<span class=\"exturl\" data-url=\"aHR0cDovL3NwcmluZy5hcHBsaWNhdGlvbi5uYW1l\">spring.application.name</span>].yaml 这个文件一定会加载，因此多环境共享配置可以写入这个文现在我的 nacos 的配置中有如下配置：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220841.jpg\" alt=\"image.png\"> 我实际代码中的配置是这样的：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 服务名称 + 服务地址 + 后缀名  --> nacos 中的配置 dataID</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">application</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> userservice</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token key atrule\">profiles</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token key atrule\">active</span><span class=\"token punctuation\">:</span> dev <span class=\"token comment\"># 环境</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token key atrule\">cloud</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">nacos</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token key atrule\">server-addr</span><span class=\"token punctuation\">:</span> localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8848</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token key atrule\">discovery</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c  <span class=\"token comment\"># dev 环境</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>      <span class=\"token key atrule\">config</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token key atrule\">file-extension</span><span class=\"token punctuation\">:</span> yaml <span class=\"token comment\"># 文件后缀名</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> fe5ad009<span class=\"token punctuation\">-</span>268c<span class=\"token punctuation\">-</span>46e7<span class=\"token punctuation\">-</span>8d90<span class=\"token punctuation\">-</span>968f160e850c</pre></td></tr></table></figure><p>那我在 userservice.yaml 中配置的信息一定会被加载读取的到。现在来看看配置的优先级：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220843.jpg\" alt=\"image.png\"> 总结一波：微服务会从 nacos 读取的配置文件：[服务名]-[spring.profile.active].yaml，环境配置 [服务名].yaml，默认配置，多环境共享优先级：[服务名]-[环境].yaml &gt;[服务名].yaml &gt; 本地配置</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/http%E5%AE%A2%E6%88%B7%E7%AB%AFFeign/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/http%E5%AE%A2%E6%88%B7%E7%AB%AFFeign/",
            "title": "http客户端Feign",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"old调用方式劣势\"><a class=\"markdownIt-Anchor\" href=\"#old调用方式劣势\">#</a> old 调用方式劣势？</h2>\n<p>以前写的 RestTemplate 调用有什么劣势？</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Order</span> <span class=\"token function\">queryOrderById</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> orderId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token comment\">// 1. 查询订单</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">Order</span> order <span class=\"token operator\">=</span> orderMapper<span class=\"token punctuation\">.</span><span class=\"token function\">findById</span><span class=\"token punctuation\">(</span>orderId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 2. 利用 RestTemplate 发送 http 请求，查询用户信息</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 2.1 设置 url 地址</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">String</span> url <span class=\"token operator\">=</span> <span class=\"token string\">\"http://userservice/user/\"</span><span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span><span class=\"token function\">getUserId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">// 2.2 发送 Http 请求，实现远程调用</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 2.3 封装 user 到 Order 中</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        order<span class=\"token punctuation\">.</span><span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">// 4. 返回</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>存在下面的问题：</p>\n<ul>\n<li>代码可读性差，编程体验不统一</li>\n<li>参数复杂 URL 难以维护</li>\n</ul>\n<p>所以，我们使用一种 http 客户端 FeginFeign 是一个声明式的 http 客户端，其作用就是帮助我们优雅的实现 http 请求的发送.</p>\n<h2 id=\"feign的使用步骤\"><a class=\"markdownIt-Anchor\" href=\"#feign的使用步骤\">#</a> Feign 的使用步骤</h2>\n<h3 id=\"引入依赖\"><a class=\"markdownIt-Anchor\" href=\"#引入依赖\">#</a> 引入依赖</h3>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">&lt;!-- 配置 feign 的客户端 --></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.cloud<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-cloud-starter-openfeign<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><h3 id=\"添加enablefeignclients注解开关\"><a class=\"markdownIt-Anchor\" href=\"#添加enablefeignclients注解开关\">#</a> 添加 @EnableFeignClients 注解（开关）</h3>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220730.jpg\" alt=\"image.png\"> 注意：在主类上开启 EnableFeignClients 注解，那么我们的程序将会自动扫描 clsspath 下面所有被 Feignclient 注解类，（value 值为服务名称）打上该注解的 bean（一般是接口，生成代理类当成 bean）, 会注入到 spring 的 ioc 容器中，最后通过处理器一系列复杂的操作，最后给我们的服务端发送一个 http 的请求。</p>\n<h3 id=\"编写feignclient接口\"><a class=\"markdownIt-Anchor\" href=\"#编写feignclient接口\">#</a> 编写 FeignClient 接口</h3>\n<p>例如：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@FeignClient</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"userservice\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserClient</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/user/&#123;id&#125;\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token class-name\">User</span> <span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathVariable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"使用feignclient中定义的方法代替resttemplate\"><a class=\"markdownIt-Anchor\" href=\"#使用feignclient中定义的方法代替resttemplate\">#</a> 使用 FeignClient 中定义的方法代替 RestTemplate</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Autowired</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span> <span class=\"token class-name\">UserClient</span> userClient<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 注入</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token class-name\">Order</span> <span class=\"token function\">queryOrderById</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> orderId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">// 1. 查询订单</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token class-name\">Order</span> order <span class=\"token operator\">=</span> orderMapper<span class=\"token punctuation\">.</span><span class=\"token function\">findById</span><span class=\"token punctuation\">(</span>orderId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> userClient<span class=\"token punctuation\">.</span><span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span><span class=\"token function\">getUserId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//  调用即可</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">// 2.3 封装 user 到 Order 中</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        order<span class=\"token punctuation\">.</span><span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 4. 返回</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>正常的注入后，调用接口中的方法即可。</p>\n<h2 id=\"feign的配置\"><a class=\"markdownIt-Anchor\" href=\"#feign的配置\">#</a> Feign 的配置</h2>\n<p>我们可以通过自动的配置，来覆盖 Feign 原本的配置。</p>\n<table>\n<thead>\n<tr>\n<th><strong>类型</strong></th>\n<th><strong>作用</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>feign.Logger.Level</strong></td>\n<td>修改日志级别</td>\n<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>\n</tr>\n<tr>\n<td>feign.codec.Decoder</td>\n<td>响应结果的解析器</td>\n<td>http 远程调用的结果做解析，例如解析 json 字符串为 java 对象</td>\n</tr>\n<tr>\n<td>feign.codec.Encoder</td>\n<td>请求参数编码</td>\n<td>将请求参数编码，便于通过 http 请求发送</td>\n</tr>\n<tr>\n<td>feign. Contract</td>\n<td>支持的注解格式</td>\n<td>默认是 SpringMVC 的注解</td>\n</tr>\n<tr>\n<td>feign. Retryer</td>\n<td>失败重试机制</td>\n<td>请求失败的重试机制，默认是没有，不过会使用 Ribbon 的重试</td>\n</tr>\n</tbody>\n</table>\n<p>** 我们可配置日志等级：**** 例如：** 全局生效：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">feign</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">client</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token key atrule\">config</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      <span class=\"token key atrule\">default</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 这里用 default 就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token key atrule\">logger-level</span><span class=\"token punctuation\">:</span> full  <span class=\"token comment\"># 配置为 FULL 格式的</span></pre></td></tr></table></figure><p>局部生效：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">feign</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">client</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token key atrule\">config</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>       <span class=\"token key atrule\">userservice</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 这里用 default 就是全局配置，如果是写服务名称，则是针对某个微服务的配置\u000b</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token key atrule\">logger-level</span><span class=\"token punctuation\">:</span> full  <span class=\"token comment\"># 配置为 FULL 格式的</span></pre></td></tr></table></figure><p>FULL 格式：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220733.jpg\" alt=\"image.png\">java 代码的方式配置：首先创建一个配置类，来创建 bean;</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FeignClientConfig</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token annotation punctuation\">@Bean</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Logger<span class=\"token punctuation\">.</span>Level</span> <span class=\"token function\">feignLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Logger<span class=\"token punctuation\">.</span>Level</span><span class=\"token punctuation\">.</span><span class=\"token constant\">BASIC</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>然后，在开启注解上声明当前为类为配置类，这样好管理一些：默认配置：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@EnableFeignClients</span><span class=\"token punctuation\">(</span>defaultConfiguration <span class=\"token operator\">=</span> <span class=\"token class-name\">FeignClientConfig</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>指定服务配置：</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@FeignClient</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"userservice\"</span><span class=\"token punctuation\">,</span> configuration <span class=\"token operator\">=</span> <span class=\"token class-name\">FeignClientConfiguration</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"总结一下\"><a class=\"markdownIt-Anchor\" href=\"#总结一下\">#</a> 总结一下：</h3>\n<p>Feign 的日志配置：1、 方式一是配置文件，</p>\n<ul>\n<li>feign.client.config.xxx.loggerLevel\n<ul>\n<li>如果 xxx 是 default 则代表全局</li>\n<li>如果 xxx 是服务名称，例如 userservice 则代表某服务</li>\n</ul>\n</li>\n</ul>\n<p>2、方式二是 java 代码配置 Logger.Level 这个 Bean</p>\n<ul>\n<li>如果在 @EnableFeignClients 注解声明则代表全局</li>\n<li>如果在 @FeignClient 注解中声明则代表某服务</li>\n</ul>\n<p>注意：如果我们每次请求都是新建一个连接，这样访问速度是不是会很慢，如果我们可以使用像 durid 连接池那样，连接宿舍是不是会很快。Feign 底层的客户端实现：</p>\n<ul>\n<li>URLConnection：默认实现，不支持连接池</li>\n<li>Apache HttpClient ：支持连接池</li>\n<li>OKHttp：支持连接池</li>\n</ul>\n<h2 id=\"如何使用连接池呢\"><a class=\"markdownIt-Anchor\" href=\"#如何使用连接池呢\">#</a> 如何使用连接池呢？</h2>\n<p>引入依赖：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">&lt;!--httpClient 的依赖 --></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>io.github.openfeign<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>feign-httpclient<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>         <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>配置连接池：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># feign 连接至配置</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token key atrule\">feign</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">client</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">config</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      <span class=\"token key atrule\">default</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token key atrule\">logger-level</span><span class=\"token punctuation\">:</span> full</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token key atrule\">httpclient</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>  <span class=\"token comment\"># 开启 feign 对 HttpClient 的支持</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token key atrule\">max-connections</span><span class=\"token punctuation\">:</span> <span class=\"token number\">200</span>  <span class=\"token comment\"># 最大的连接数</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token key atrule\">max-connections-per-route</span><span class=\"token punctuation\">:</span> <span class=\"token number\">50</span>  <span class=\"token comment\"># 每个路径的最大连接数</span></pre></td></tr></table></figure><h3 id=\"feign的优化\"><a class=\"markdownIt-Anchor\" href=\"#feign的优化\">#</a> Feign 的优化：</h3>\n<p>1、日志级别尽量用 basic2、使用 HttpClient 或 OKHttp 代替 URLConnection</p>\n<ul>\n<li>引入 feign-httpClient 依赖配置文件</li>\n<li>开启 httpClient 功能，设置连接池参数</li>\n</ul>\n<h2 id=\"feign的最佳实战我感觉这样好一些\"><a class=\"markdownIt-Anchor\" href=\"#feign的最佳实战我感觉这样好一些\">#</a> Feign 的最佳实战（我感觉这样好一些）：</h2>\n<p>将 FeignClient 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220735.jpg\" alt=\"image.png\"></p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80/",
            "title": "微服务基础",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"微服务是什么\"><a class=\"markdownIt-Anchor\" href=\"#微服务是什么\">#</a> 微服务是什么？</h2>\n<p>微服务是一种经过良好架构设计的<strong>分布式</strong>架构方案，微服务架构体系特征：</p>\n<ul>\n<li>单一职责：微服务拆分粒度更小，每个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</li>\n<li>面向服务：微服务对外暴露业务接口</li>\n<li>自治：团队独立、技术独立、数据独立、部署独立</li>\n<li>隔离性：服务调用做好隔离、容错、降级，避免出现级联问题</li>\n</ul>\n<h2 id=\"微服务结构\"><a class=\"markdownIt-Anchor\" href=\"#微服务结构\">#</a> 微服务结构</h2>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220917.jpg\" alt=\"image.png\"> 微服务的实现：SpringCloud 和 Dubbo, 需要布置集群</p>\n<h2 id=\"提供者和消费者\"><a class=\"markdownIt-Anchor\" href=\"#提供者和消费者\">#</a> 提供者和消费者</h2>\n<p>服务提供者：在一次业务中，被其他微服务调用的服务。（提供接口给其他微服务）服务消费者：在一次业务中，调用其他微服务的服务。（调用其他微服务提供的接口）一个服务既可以是消费者，也可以是消费者。（相对的）</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/",
            "title": "服务拆分以及远程调用",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h1 id=\"服务拆分注意事项\"><a class=\"markdownIt-Anchor\" href=\"#服务拆分注意事项\">#</a> 服务拆分注意事项：</h1>\n<p>1、 不同微服务，不要重复开发相同业务 2、微服务数据独立，不可以访问其他微服务数据库 3、 微服务可以将自己的业务暴露为接口，以供其他服务使用</p>\n<h2 id=\"远程调用\"><a class=\"markdownIt-Anchor\" href=\"#远程调用\">#</a> 远程调用</h2>\n<p>原来：我们只需在浏览器中发送相应的请求即可获取返回的数据，这样我们就能获取信息了，那么现在我们能用在我们其他模块中发起同样的请求来获取数据呢？我们可以使用 Spring 提供的请求方式 RestTemplate 来发送请求，当我们发送 get 请求时，我们只需调用 getForObject 方法，post 请求发送 postForObject 方法。</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RebitMQ%E9%A3%9F%E7%94%A8%E6%95%99%E7%A8%8B/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RebitMQ%E9%A3%9F%E7%94%A8%E6%95%99%E7%A8%8B/",
            "title": "消息中间件RebitMQ食用教程",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"一-初识mq\"><a class=\"markdownIt-Anchor\" href=\"#一-初识mq\">#</a> 一、初识 MQ</h2>\n<p>同步调用的问题微服务间基于 Feign 的调用就属于同步方式，存在一些问题。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220922.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220926.jpg\" alt=\"image.png\"></p>\n<h3 id=\"同步调用的优点\"><a class=\"markdownIt-Anchor\" href=\"#同步调用的优点\">#</a> 同步调用的优点：</h3>\n<p>时效性较强，可以立即得到结果</p>\n<h3 id=\"同步调用的问题\"><a class=\"markdownIt-Anchor\" href=\"#同步调用的问题\">#</a> 同步调用的问题：</h3>\n<p>耦合度高性能和吞吐能力下降有额外的资源消耗有级联失败问题</p>\n<p>故此异步调用方案产生：异步调用常见实现就是事件驱动模式<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220931.jpg\" alt=\"image.png\"></p>\n<h3 id=\"事件驱动的优势\"><a class=\"markdownIt-Anchor\" href=\"#事件驱动的优势\">#</a> 事件驱动的优势：</h3>\n<p>优势一：服务解耦<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220936.jpg\" alt=\"image.png\"> 优势二：性能提升，吞吐量提高<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220940.jpg\" alt=\"image.png\"> 优势三：服务没有强依赖，不担心级联失败问题<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220944.jpg\" alt=\"image.png\"> 优势四：流量削峰<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220949.jpg\" alt=\"image.png\"></p>\n<h3 id=\"异步通信的优点\"><a class=\"markdownIt-Anchor\" href=\"#异步通信的优点\">#</a> 异步通信的优点：</h3>\n<p>耦合度低吞吐量提升故障隔离流量削峰</p>\n<h4 id=\"异步通信的缺点\"><a class=\"markdownIt-Anchor\" href=\"#异步通信的缺点\">#</a> 异步通信的缺点：</h4>\n<p>依赖于 Broker 的可靠性、安全性、吞吐能力架构复杂了，业务没有明显的流程线，不好追踪管理<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220953.jpg\" alt=\"image.png\"></p>\n<h2 id=\"二-rabbitmq快速入门\"><a class=\"markdownIt-Anchor\" href=\"#二-rabbitmq快速入门\">#</a> 二、RabbitMQ 快速入门</h2>\n<h3 id=\"安装rabbitmq\"><a class=\"markdownIt-Anchor\" href=\"#安装rabbitmq\">#</a> 安装 RabbitMQ</h3>\n<p>在线拉取：docker pull rabbitmq:3-management</p>\n<p>启动命令： （注释去掉）docker run \\ -e RABBITMQ_DEFAULT_USER=lyggwsp \\ -e RABBITMQ_DEFAULT_PASS=wyr0307 \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\  # 管理访问端口 -p 5672:5672 \\  # 通讯端口 -d \\ rabbitmq:3-management</p>\n<p>我们访问主机地址 + 15672 端口任然无效，是因为我们插件没开：进入容器内部：docker exec -it mq bash 修改插件：rabbitmq-plugins enable rabbitmq_management 这样我们访问就有效了。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220957.jpg\" alt=\"image.png\"></p>\n<p>rabbitmq 的结构和概念：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221001.jpg\" alt=\"image.png\"></p>\n<h3 id=\"rabbitmq中的几个概念\"><a class=\"markdownIt-Anchor\" href=\"#rabbitmq中的几个概念\">#</a> RabbitMQ 中的几个概念：</h3>\n<p>channel：操作 MQ 的工具 exchange：路由消息到队列中 queue：缓存消息 virtual host：虚拟主机，是对 queue、exchange 等资源的逻辑分组</p>\n<p>常见的消息模型：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221005.jpg\" alt=\"image.png\"> 官方的 HelloWorld 是基于最基础的消息队列模型来实现的，只包括三个角色：</p>\n<ul>\n<li>publisher：消息发布者，将消息发送到队列</li>\n<li>queuequeue：消息队列，负责接受并缓存消息</li>\n<li>consumer：订阅队列，处理队列中的消息</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221009.jpg\" alt=\"image.png\"></p>\n<h3 id=\"基本消息队列的消息发送流程\"><a class=\"markdownIt-Anchor\" href=\"#基本消息队列的消息发送流程\">#</a> 基本消息队列的消息发送流程：</h3>\n<p>建立 connection 创建 channel 利用 channel 声明队列利用 channel 向队列发送消息基本消息队列的消息接收流程：建立 connection 创建 channel 利用 channel 声明队列定义 consumer 的消费行为 handleDelivery () 利用 channel 将消费者与队列绑定</p>\n<h2 id=\"三-springamqp\"><a class=\"markdownIt-Anchor\" href=\"#三-springamqp\">#</a> 三、SpringAMQP</h2>\n<p>步骤 1：引入 AMQP 依赖因为 publisher 和 consumer 服务都需要 amqp 依赖，因此这里把依赖直接放到父工程 mq-demo 中：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221013.jpg\" alt=\"image.png\"> 步骤 2：在 publisher 中编写测试方法，向 simple.queue 发送消息</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">rabbitmq</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\"># 主机名</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span> 101.42.152.244</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5672</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">#虚拟主机</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">virtual-host</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\"># 用户名</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> lyggwsp</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\"># 密码</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> wyr0307</pre></td></tr></table></figure><figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@RunWith</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SpringRunner</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token annotation punctuation\">@SpringBootTest</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpringAMOPTest</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token annotation punctuation\">@Autowired</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token class-name\">RabbitTemplate</span> rabbitTemplate<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token annotation punctuation\">@Test</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">String</span> queueName <span class=\"token operator\">=</span> <span class=\"token string\">\"simple.queue\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token class-name\">String</span> message <span class=\"token operator\">=</span> <span class=\"token string\">\"hello,my name is publisher\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        rabbitTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">convertAndSend</span><span class=\"token punctuation\">(</span>queueName<span class=\"token punctuation\">,</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"什么是amqp\"><a class=\"markdownIt-Anchor\" href=\"#什么是amqp\">#</a> 什么是 AMQP？</h4>\n<p>应用间消息通信的一种协议，与语言和平台无关。</p>\n<h4 id=\"springamqp如何发送消息\"><a class=\"markdownIt-Anchor\" href=\"#springamqp如何发送消息\">#</a> SpringAMQP 如何发送消息？</h4>\n<p>引入 amqp 的 starter 依赖配置 RabbitMQ 地址利用 RabbitTemplate 的 convertAndSend 方法</p>\n<p>步骤 3：在 consumer 中编写消费逻辑，监听 simple.queue</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">rabbitmq</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\"># 主机名</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span> 101.42.152.244</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5672</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">#虚拟主机</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">virtual-host</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\"># 用户名</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> lyggwsp</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\"># 密码</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> wyr0307</pre></td></tr></table></figure><p>这是一个组件一个组件！！！！</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token annotation punctuation\">@Component</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpringAMOPA</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token annotation punctuation\">@RabbitListener</span><span class=\"token punctuation\">(</span>queues <span class=\"token operator\">=</span> <span class=\"token string\">\"simple.queue\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">t</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"接收到的消息是：\"</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>SpringAMQP 如何接收消息？引入 amqp 的 starter 依赖配置 RabbitMQ 地址定义类，添加 @Component 注解类中声明方法，添加 @RabbitListener 注解，方法参数就时消息注意：消息一旦消费就会从队列删除，RabbitMQ 没有消息回溯功能</p>\n<p>Work Queue 工作队列 Work queue，工作队列，可以提高消息处理速度，避免队列消息堆积<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221016.jpg\" alt=\"image.png\"> 模拟 WorkQueue，实现一个队列绑定多个消费者</p>\n<p>基本思路如下：在 publisher 服务中定义测试方法，每秒产生 50 条消息，发送到 simple.queue 在 consumer 服务中定义两个消息监听者，都监听 simple.queue 队列消费者 1 每秒处理 50 条消息，消费者 2 每秒处理 10 条消息</p>\n<p>这玩意讲的也就是一个重点：（在监听者 yml 配置文件中多配置一下 prefetch：）</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">rabbitmq</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\"># 主机名</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span> 101.42.152.244</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5672</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">#虚拟主机</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token key atrule\">virtual-host</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\"># 用户名</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> lyggwsp</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\"># 密码</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> wyr0307</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\"># 控制预取消息的上限</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token key atrule\">listener</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>      <span class=\"token key atrule\">simple</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token key atrule\">prefetch</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token comment\"># 每次只能获取一条消息，处理完成之后才能获取下一条</span></pre></td></tr></table></figure><h3 id=\"work模型的使用\"><a class=\"markdownIt-Anchor\" href=\"#work模型的使用\">#</a> Work 模型的使用：</h3>\n<p>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理通过设置 prefetch 来控制消费者预取的消息数量</p>\n<p>发布（ Publish ）、订阅（ Subscribe ）发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了 exchange（交换机）。常见 exchange 类型包括：Fanout：广播 Direct：路由 Topic：话题<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221020.jpg\" alt=\"image.png\"> 注意：exchange 负责消息路由，而不是存储，路由失败则消息丢失</p>\n<h4 id=\"发布订阅-fanout-exchange\"><a class=\"markdownIt-Anchor\" href=\"#发布订阅-fanout-exchange\">#</a> 发布订阅 - Fanout Exchange</h4>\n<p>Fanout Exchange 会将接收到的消息广播到每一个跟其绑定的 queue<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221024.jpg\" alt=\"image.png\"></p>\n<h3 id=\"basic-queue-简单队列模型\"><a class=\"markdownIt-Anchor\" href=\"#basic-queue-简单队列模型\">#</a> Basic Queue 简单队列模型</h3>\n<h3 id=\"work-queue-工作队列模型\"><a class=\"markdownIt-Anchor\" href=\"#work-queue-工作队列模型\">#</a> Work Queue 工作队列模型</h3>\n<h3 id=\"发布-订阅模型-fanout\"><a class=\"markdownIt-Anchor\" href=\"#发布-订阅模型-fanout\">#</a> 发布、订阅模型 - Fanout</h3>\n<h3 id=\"发布-订阅模型-direct\"><a class=\"markdownIt-Anchor\" href=\"#发布-订阅模型-direct\">#</a> 发布、订阅模型 - Direct</h3>\n<h3 id=\"发布-订阅模型-topic\"><a class=\"markdownIt-Anchor\" href=\"#发布-订阅模型-topic\">#</a> 发布、订阅模型 - Topic</h3>\n<h3 id=\"消息转换器\"><a class=\"markdownIt-Anchor\" href=\"#消息转换器\">#</a> 消息转换器</h3>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%9F%BA%E7%A1%80/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%9F%BA%E7%A1%80/",
            "title": "Redis基础",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-为什么要使用redis而不使用session\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么要使用redis而不使用session\">#</a> 1、为什么要使用 redis，而不使用 Session?</h2>\n<ol>\n<li>使用 Redis 而不使用传统的 Session 的主要原因是为了减轻服务器负载和提高性能。Redis 是一个高性能的基于内存的键值存储系统，相比传统的会话存储方式，使用 Redis 可以获得以下好处：\n<ul>\n<li>高性能和低延迟：Redis 的读写速度非常快，可以显著减少读写操作的延迟，提高响应速度。</li>\n<li>可扩展性：Redis 支持分布式部署，可以实现数据的负载均衡和横向扩展，提高系统的可扩展性和容量。</li>\n<li>持久化支持：Redis 提供将数据持久化到磁盘的功能，以防止数据丢失，保证数据的可靠性。</li>\n<li>丰富的功能：Redis 提供了许多附加功能，如发布 / 订阅机制、事务支持、键过期等，可以增加会话管理的灵活性和功能扩展性。</li>\n</ul>\n</li>\n<li>传统的 Session 在分布式环境下无法实现会话共享和资源共享。由于每个服务器都拥有自己的本地 Session 存储，不同服务器之间无法直接共享 Session 数据，这会导致用户在不同服务器之间会话状态不一致的问题。而使用 Redis 作为中央会话存储，可以解决这个问题，各个服务器可以共享和访问相同的会话数据，实现会话的共享和一致性。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/",
            "title": "乐观锁和悲观锁",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-基本概念\"><a class=\"markdownIt-Anchor\" href=\"#1-基本概念\">#</a> 1、基本概念</h2>\n<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p>\n<ul>\n<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>\n<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/",
            "title": "全局唯一ID",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-需求描述\"><a class=\"markdownIt-Anchor\" href=\"#1-需求描述\">#</a> 1、需求描述</h2>\n<p>当数据量很大，并且要求 ID 唯一的时候，我们需要生成唯一 ID，我们可能会根据 ID 去不同的表中对比获取数据。所以全局唯一 ID 的两个核心需求就是：① 全局唯一性② 粗略有序性</p>\n<h2 id=\"2-使用数据库自增id优缺点\"><a class=\"markdownIt-Anchor\" href=\"#2-使用数据库自增id优缺点\">#</a> 2、使用数据库自增 ID 优缺点</h2>\n<p>如果使用数据库提供的自增 ID 来实现，这样的 ID 会太明显，数据量过大需要进行分表时，两个表都进行生成唯一 ID，ID 可能会冲突。mysql 自带自增生成 id，oracle 可以用序列生成 id, 但在数据库集群环境下，扩展性不好</p>\n<h2 id=\"3-使用uuid的优缺点\"><a class=\"markdownIt-Anchor\" href=\"#3-使用uuid的优缺点\">#</a> 3、使用 UUID 的优缺点</h2>\n<p>① 生成的 ID 太长，没有任何规律性② uuid 生成全球唯一 id, 生成方式简单粗暴，本地生成，没有网络开销，效率高；缺点长度较长，没有递增趋势性，不易维护，常用于生成 token 令牌。</p>\n<h2 id=\"4-雪花id优缺点\"><a class=\"markdownIt-Anchor\" href=\"#4-雪花id优缺点\">#</a> 4、雪花 ID 优缺点</h2>\n<p>基于雪花算法 snowflake 生成全局 id，本地生成，没有网络开销，效率高，但是依赖机器时钟。</p>\n<h2 id=\"5-redis-生成全局唯一id\"><a class=\"markdownIt-Anchor\" href=\"#5-redis-生成全局唯一id\">#</a> 5、Redis 生成全局唯一 ID</h2>\n<p>基于 redis 单线程的特点生成全局唯一 id，redis 性能高，支持集群分片。为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220545.jpg\" alt=\"image.png\">ID 的组成部分：符号位：1bit，永远为 0 时间戳：31bit，以秒为单位，可以使用 69 年序列号：32bit，秒内的计数器，支持每秒产生 2^32 个不同 ID 实现：</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/",
            "title": "缓存更新策略",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"操作缓存和数据库的时候有三个问题需要考虑\"><a class=\"markdownIt-Anchor\" href=\"#操作缓存和数据库的时候有三个问题需要考虑\">#</a> 操作缓存和数据库的时候有三个问题需要考虑：</h2>\n<h3 id=\"1-删除缓存还是更新缓存\"><a class=\"markdownIt-Anchor\" href=\"#1-删除缓存还是更新缓存\">#</a> 1、删除缓存还是更新缓存？</h3>\n<p>① 更新缓存的话，每次更新数据库都需要更新缓存，无效写操作操作。② 删除缓存的话，更新数据库时让缓存失效，查询时再更新缓存。结合两者的优缺点 **，最优者为②**，减少无效的写操作。</p>\n<h3 id=\"2-如何保证缓存与数据库的操作的同时成功和失败\"><a class=\"markdownIt-Anchor\" href=\"#2-如何保证缓存与数据库的操作的同时成功和失败\">#</a> 2、 如何保证缓存与数据库的操作的同时成功和失败？</h3>\n<p>① 单体项目，将缓存与数据库操作放在一个事务中② 分布式系统，利用 TCC 等分布式事务方案</p>\n<h3 id=\"3-先操作缓存还是先操作数据库\"><a class=\"markdownIt-Anchor\" href=\"#3-先操作缓存还是先操作数据库\">#</a> 3、先操作缓存还是先操作数据库？</h3>\n<p>① 先删除缓存，再操作数据库② 先操作数据库，再删除缓存这两种操作上看似都是可以的，我们来深入探究一下到底是那种操作更胜一筹。<strong>先操作缓存再操作数据库：</strong><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220548.jpg\" alt=\"image.png\"> 假如：两个线程并行的对数据进行操作，线程 1 先删除缓存，后立即更新了数据库，使得 V 变为 20，这时线程 2 才进行查询操作，发现缓存没有命中，这时会进行查询数据库，并将查询到的信息写入到 Redis 缓存中。这样的操作是合理的。但是如果是这种情况呢？<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220550.jpg\" alt=\"image.png\"> 还是两个线程并行，线程 1 先删除了缓存，因为删除缓存的速度一般是微秒级别的，并更新数据库，因为写的操作数据库的速度要远大于操作 Redis 的速度，这时线程 2 开始了操作并查询了缓存，发现缓存不存在然后就去查询数据库，后写入缓存中。导致缓存中的数据是 V=10, 而这时线程 1 接着继续操作数据库并更新了 V=20, 这时就会导致缓存中的数据和数据库中的数据不一致。这种情况下，写入缓存的速度要远快于更新数据库的速度，所以这种情况发生的概率比较大。</p>\n<p><strong>先操作数据库，再删除缓存</strong><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220553.jpg\" alt=\"image.png\"> 线程 1、线程 2 并行执行，线程 2 先操作了数据库，将 V 变为 20，然后将缓存清空。这时线程 1 执行查询操作，没有命中就从数据库中获取数据，后写入到 Redis 中。这种情况下是看似是可行的。我们接着看下面这种情况：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220556.jpg\" alt=\"image.png\"> 同样线程 1 和线程 2 并行执行，线程 1 先查询缓存，没有命中就去数据库中获取数据，这时线程 2 更新了数据库使得 V=20, 然后将缓存清空，这时线程 1 继续执行将获取到的信息再写入到 Redis 中，这时缓存的数据为线程 1 获取到的旧数据，这时缓存和数据库中的信息是不一致的。但是在写如缓存中的速度要远快于更新数据库的速度，并且线程 2 还对缓存进行了删除。所以这种情况的发送的改了较先删除缓存，再操作数据库发送的概率要低的多。<strong>总结：这两种方案都有可能出现数据的不一致性。最终我们选择先操作数据库后操作缓存作为我们的最佳实战策略。</strong></p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF/",
            "title": "缓存穿透、雪崩、击穿",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-缓存穿透\"><a class=\"markdownIt-Anchor\" href=\"#1-缓存穿透\">#</a> 1、缓存穿透</h2>\n<h3 id=\"1-定义\"><a class=\"markdownIt-Anchor\" href=\"#1-定义\">#</a> 1、定义</h3>\n<p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打到数据库上。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220559.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220601.jpg\" alt=\"image.png\"></p>\n<h3 id=\"2-产生原因\"><a class=\"markdownIt-Anchor\" href=\"#2-产生原因\">#</a> 2、产生原因</h3>\n<ol>\n<li>自身业务代码问题</li>\n<li>恶意攻击，爬虫造成空命中</li>\n</ol>\n<h3 id=\"3-常见的两种解决方案\"><a class=\"markdownIt-Anchor\" href=\"#3-常见的两种解决方案\">#</a> 3、常见的两种解决方案</h3>\n<h4 id=\"缓存空对象\"><a class=\"markdownIt-Anchor\" href=\"#缓存空对象\">#</a> 缓存空对象</h4>\n<p>优点：实现简单，维护方便缺点：① 额外的内存消耗② 可能造成短期的不一致<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220603.jpg\" alt=\"image.png\"></p>\n<h4 id=\"布隆过滤器\"><a class=\"markdownIt-Anchor\" href=\"#布隆过滤器\">#</a> 布隆过滤器</h4>\n<p>优点：内存占用较少，没有多余 Key 缺点：① 实现复杂② 存在误判可能<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220606.jpg\" alt=\"image.png\"> 补充：布隆过滤器，当再布隆过滤器中获取数据说是不存在时，那一定是不存在的，但是如果说是存在的话，数据实际上说不定是不存在的。所以使用布隆过滤器也可能会出现缓存穿透问题。</p>\n<h4 id=\"增强id的复杂度避免被猜测id规律\"><a class=\"markdownIt-Anchor\" href=\"#增强id的复杂度避免被猜测id规律\">#</a> 增强 id 的复杂度避免被猜测 id 规律</h4>\n<h4 id=\"做好数据的基础格式校验\"><a class=\"markdownIt-Anchor\" href=\"#做好数据的基础格式校验\">#</a> 做好数据的基础格式校验</h4>\n<h4 id=\"加强用户权限校验\"><a class=\"markdownIt-Anchor\" href=\"#加强用户权限校验\">#</a> 加强用户权限校验</h4>\n<h4 id=\"做好热点参数的限流\"><a class=\"markdownIt-Anchor\" href=\"#做好热点参数的限流\">#</a> 做好热点参数的限流</h4>\n<h2 id=\"2-缓存雪崩\"><a class=\"markdownIt-Anchor\" href=\"#2-缓存雪崩\">#</a> 2、缓存雪崩</h2>\n<h3 id=\"1-定义-2\"><a class=\"markdownIt-Anchor\" href=\"#1-定义-2\">#</a> 1、定义</h3>\n<p>缓存雪崩是指在同一时段大量的缓存 Key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220608.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220610.jpg\" alt=\"image.png\"></p>\n<h4 id=\"2-解决方案\"><a class=\"markdownIt-Anchor\" href=\"#2-解决方案\">#</a> 2、解决方案</h4>\n<ul>\n<li>给不同的 Key 的 TTL 添加随机值</li>\n<li>利用 Redis 集群提高服务的可用性</li>\n<li>给缓存业务添加降级限流策略</li>\n<li>给业务添加多级缓存</li>\n</ul>\n<h2 id=\"3-缓存击穿\"><a class=\"markdownIt-Anchor\" href=\"#3-缓存击穿\">#</a> 3、缓存击穿</h2>\n<h3 id=\"1-定义-3\"><a class=\"markdownIt-Anchor\" href=\"#1-定义-3\">#</a> 1、定义</h3>\n<p>缓存击穿问题也叫做热点 Key 问题，就是一个高并发访问并且缓存重建业务比较复杂的 Key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220613.jpg\" alt=\"image.png\"> 如上图所示的，线程 1 查询缓存但是缓存并没有命中，就开始查询数据库了，然后线程 2、3、4 也陆续查询了缓存没有命中，都去查询数据库并重建缓存。导致 db 的压力猛增，造成 dp 有可能会宕机。</p>\n<h3 id=\"2-解决方案-2\"><a class=\"markdownIt-Anchor\" href=\"#2-解决方案-2\">#</a> 2、解决方案</h3>\n<h4 id=\"1-互斥锁\"><a class=\"markdownIt-Anchor\" href=\"#1-互斥锁\">#</a> ① 互斥锁</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220615.jpg\" alt=\"image.png\"> 如上图所示：线程 1 和线程 2，线程 1 先查询缓存，但是没有命中，然后线程 1 获取互斥锁，后进行查询数据库重建数据缓存，期间线程 2 查询缓存，同样没有命中，接着线程 2 获取互斥锁，但是并没有获取到锁，所以线程 2 就在等待并重试，直到线程 1 重建数据缓存并写入缓存结束后释放互斥锁，然后线程 2 获取到互斥锁缓存命中获取到数据就可以返回了。</p>\n<h4 id=\"2-逻辑过期\"><a class=\"markdownIt-Anchor\" href=\"#2-逻辑过期\">#</a> ② 逻辑过期</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220617.jpg\" alt=\"image.png\"> 上图为逻辑过期的处理流程：线程 1 查询缓存，发现逻辑过期时间已经过期了，后获取互斥锁，然后开启新的线程：线程 2，而线程 1 直接拿旧的数据返回了，线程 2 重建数据并设置逻辑过期时间，在此时间之内线程 3 查询缓存发现逻辑过期时间过期了，并且获取互斥锁失败，那么就证明有线程在重建数据了，线程 3 就拿旧的数据返回。这时线程 2 重构数据成功，并释放了互斥锁。线程 4 过来直接直接命中缓存并且没有逻辑过期，就返回了。</p>\n<h4 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结：</h4>\n<p>两种方式各有优缺点：</p>\n<table>\n<thead>\n<tr>\n<th><strong>解决方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>互斥锁</strong></td>\n<td>没有额外的内存消耗保证一致性实现简单</td>\n<td>线程需要等待，性能受影响可能有死锁风险</td>\n</tr>\n<tr>\n<td><strong>逻辑过期</strong></td>\n<td>线程无需等待，性能较好</td>\n<td>不保证一致性有额外内存消耗实现复杂</td>\n</tr>\n</tbody>\n</table>\n<p>建议再看一篇这个文章，写的比我好多了：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGhyZWUtZmlnaHRlci9wLzE1MjUzNDUxLmh0bWw=\">十分钟彻底掌握缓存击穿、缓存穿透、缓存雪崩 - 三分恶 - 博客园</span></p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/",
            "title": "黑马点评",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-json序列化时忽略null\"><a class=\"markdownIt-Anchor\" href=\"#1-json序列化时忽略null\">#</a> 1、json 序列化时忽略 NULL?</h2>\n<p>yaml 文件配置：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">jackson</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token key atrule\">default-property-inclusion</span><span class=\"token punctuation\">:</span> non_null <span class=\"token comment\"># JSON 处理时忽略非空字段</span></pre></td></tr></table></figure><h2 id=\"2-为什么使用session的方式登录不需要返回登录凭证\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么使用session的方式登录不需要返回登录凭证\">#</a> 2、 为什么使用 Session 的方式登录不需要返回登录凭证？</h2>\n<p>因为使用 session 的话，浏览器第一次访问服务器，服务器会生成一个 key 为 JSESSIONID 的 cookie 的信息并会创建一个 SESSIONID 为 JSESSIONID 的 session。这样下次浏览器请求就会携带 cookie，并携带 JSESSIONID 信息，会找到与之匹配的 session。我们登录成功后需要将信息存储到这个 session 中，下次请求过来就直接从这个 session 中获取就可以了哦。</p>\n<h2 id=\"3-在redis中存储对象类型使用哪种数据结构\"><a class=\"markdownIt-Anchor\" href=\"#3-在redis中存储对象类型使用哪种数据结构\">#</a> 3、在 redis 中存储对象类型，使用哪种数据结构？</h2>\n<p>可以使用 String 结构，以 JSON 字符串来保存，比较直观：</p>\n<table name:Rose,age:18=\"\">\n<thead>\n<tr>\n<th><strong>KEY</strong></th>\n<th><strong>VALUE</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr name:Jack,age:21=\"\">\n<td>heima:user:1</td>\n<td></td>\n</tr>\n<tr>\n<td>heima:user:2</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Hash 结构可以将对象中的每个字段独立存储，可以针对单个字段做 CRUD，并且内存占用更少：</p>\n<table>\n<thead>\n<tr>\n<th><strong>KEY</strong></th>\n<th><strong>VALUE</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>field</td>\n<td>value</td>\n</tr>\n<tr>\n<td>heima:user:1</td>\n<td>name</td>\n<td>Jack</td>\n</tr>\n<tr>\n<td></td>\n<td>age</td>\n<td>21</td>\n</tr>\n<tr>\n<td>heima:user:2</td>\n<td>name</td>\n<td>Rose</td>\n</tr>\n<tr>\n<td></td>\n<td>age</td>\n<td>18</td>\n</tr>\n</tbody>\n</table>\n<p>对于取 Hash 信息，使用 stringRedisTemplate.opsForHash ().entries (key); 不能直接设置 hash 类型的过期时间，需要手动设置一下：例如：stringRedisTemplate.expire (tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</p>\n",
            "tags": []
        }
    ]
}