<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zrgzs.github.io/guide</id>
    <title>卓软信息工作室 • Posts by &#34;冷知识合集&#34; category</title>
    <link href="https://zrgzs.github.io/guide" />
    <updated>2023-09-07T09:59:14.000Z</updated>
    <entry>
        <id>https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/Serializable%20%E5%92%8C%20Externalizable/</id>
        <title>Serializable 和 Externalizable</title>
        <link rel="alternate" href="https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/Serializable%20%E5%92%8C%20Externalizable/"/>
        <content type="html">&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL2phdmEtdHJhbnNpZW50LWtleXdvcmRzLmh0bWw=&#34;&gt;Java transient 关键字 | 菜鸟教程&lt;/span&gt;&lt;/p&gt;
</content>
        <updated>2023-09-07T09:59:14.000Z</updated>
    </entry>
    <entry>
        <id>https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%85%88%E9%97%AE%E5%90%8E%E7%AD%94/</id>
        <title>先问后答</title>
        <link rel="alternate" href="https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%85%88%E9%97%AE%E5%90%8E%E7%AD%94/"/>
        <content type="html">&lt;p&gt;” 本贴一问一答，以问促学，对答案有疑问建议新建问题.&lt;/p&gt;
&lt;h2 id=&#34;1-问-为何-jwt-可以防止被篡改&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-问-为何-jwt-可以防止被篡改&#34;&gt;#&lt;/a&gt; 1. 问：为何 JWT 可以防止被篡改？&lt;/h2&gt;
&lt;p&gt;JSON Web Token 由三部分组成，这些部分由点 (.) 分隔，分别是：头 (Header)、有效载荷 (Playload)、签名 (Signature)；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Header：对 TokenUtil.header（含有加密算法）进行 Base64Url 编码得到 jwt 的第一部分；&lt;/li&gt;
&lt;li&gt;Playload：存放有效信息的地方，Base64Url 编码得到第二部分；&lt;/li&gt;
&lt;li&gt;Signature：是整个数据的认证信息。一般根据前两步的数据，然后通过 header 中声明的加密方式结合密钥 secret 加密，然后就构成了 jwt 的第 3 部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时 signature 字段就是关键了，能被解密出明文的，只有 header 和 payload 假如黑客 / 中间人串改了 payload，那么服务器可以通过 signature 去验证是否被篡改过&lt;strong&gt;在服务端在执行一次 signature = 加密算法 (header + “.” + payload, 密钥);, 然后对比 signature 是否一致，如果一致则说明没有被篡改。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-二叉排序树和堆的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-二叉排序树和堆的区别&#34;&gt;#&lt;/a&gt; 2. 二叉排序树和堆的区别？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;二叉排序树：每个结点的值均大于其左子树上所有结点的值，小于其右子树上所有结点的值&lt;/li&gt;
&lt;li&gt;堆：是一个完全二叉树，并且每个结点的值都大于或等于其左右孩子结点的值
&lt;ul&gt;
&lt;li&gt;并未规定左右子节点之间的大小关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用途
&lt;ul&gt;
&lt;li&gt;二叉排序树是为了实现动态查找而设计的数据结构，它是面向查找操作的，在二叉排序树中查找一个结点的平均时间复杂度是 O (log n)；&lt;/li&gt;
&lt;li&gt;堆是为了实现排序而设计的一种数据结构，它不是面向查找操作的，因而在堆中查找一个结点需要进行遍历，其平均时间复杂度是 O (n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-为什么使用-b树&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-为什么使用-b树&#34;&gt;#&lt;/a&gt; 3. 为什么使用 B + 树？&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlCNHkxdjdKeS8/c3BtX2lkX2Zyb209cGFnZURyaXZlciZhbXA7dmRfc291cmNlPTY0MDU1MmE0YTA3M2FiYjkzYTNiNzQxNDJjMjE3YWMz&#34;&gt;https://www.bilibili.com/video/BV1yB4y1v7Jy/?spm_id_from=pageDriver&amp;amp;vd_source=640552a4a073abb93a3b74142c217ac3&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;笔记&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#笔记&#34;&gt;#&lt;/a&gt; 笔记：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;首先默认读者已了解 B 树、B + 树 的基本知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在解释为什么会有 B + 树 之前，需要一些预备知识：&lt;/p&gt;
&lt;h4 id=&#34;关于磁盘&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#关于磁盘&#34;&gt;#&lt;/a&gt; 关于磁盘&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220330.jpg&#34; alt=&#34;image.png&#34;&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220332.jpg&#34; alt=&#34;image.png&#34;&gt; 磁盘读取时，系统将数据逻辑地址传给磁盘，磁盘的控制电路会解析出物理地址（哪个磁道，哪个扇区），于是磁头需要前后移动到相应的磁道 —— 寻道，消耗的时间叫 ——&lt;strong&gt; 寻道时间&lt;/strong&gt;，磁盘旋转将对应的扇区转到磁头下（磁头找到对应磁道的对应扇区），消耗的时间叫 ——&lt;strong&gt; 旋转时间&lt;/strong&gt;，这一系列操作是非常耗时。为了尽量减少 I/O 操作，计算机系统一般采取&lt;strong&gt;预读&lt;/strong&gt;的方式，&lt;strong&gt;预读的长度一般为页（page）的整倍数。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;关于页&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#关于页&#34;&gt;#&lt;/a&gt; 关于页&lt;/h4&gt;
&lt;p&gt;计算机系统是&lt;strong&gt;分页读取和存储&lt;/strong&gt;的，一般&lt;strong&gt;一页为 4KB&lt;/strong&gt;（8 个扇区，每个扇区 125B，8*125B=4KB），每次读取和存取的最小单元为一页，而 ** 磁盘预读时通常会读取页的整倍数。** 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），所以即使只需要读取一个字节，磁盘也会读取一页的数据。&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h4&gt;
&lt;p&gt;B 树是多叉树，提高了查找效率。B + 树在多叉树的基础上，令非叶子结点只存储记录和指针，不存储具体的数据，使一次 IO 读取的一个结点可以包含更多的叶子节点，也就能够包含更多数据。【参考资料】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hkXzE0MzcvYXJ0aWNsZS9kZXRhaWxzLzEwMzI1MzYzMg==&#34;&gt;https://blog.csdn.net/xd_1437/article/details/103253632&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzU0OTA2Mw==&#34;&gt;https://zhuanlan.zhihu.com/p/37549063&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2tmdmF3bC9wLzExNzMzMDU3Lmh0bWw=&#34;&gt;https://www.cnblogs.com/wkfvawl/p/11733057.html&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-为什么java中全局变量不一定初始化局部变量必须初始化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-为什么java中全局变量不一定初始化局部变量必须初始化&#34;&gt;#&lt;/a&gt; 4、为什么 Java 中全局变量不一定初始化，局部变量必须初始化？&lt;/h2&gt;
&lt;p&gt;这个问题涉及到&lt;strong&gt; JVM 类加载&lt;/strong&gt;和&lt;strong&gt;字节码执行&lt;/strong&gt;两个阶段，这两个阶段是依次执行的。JVM 类加载是 JVM 利用类加载器将 class 文件加载到 JVM 的过程，涉及 “加载”、“验证”、“” 准备 “、“” 解析 “和” 初始化 “。** 类的成员变量初始化 — 在 JVM 类加载阶段完成 **** 静态成员变量  &lt;strong&gt;会被初始化两次，第一次在 “准备” 阶段，先进行一次初始化，系统附上默认值；第二次在&lt;/strong&gt; “初始化” 阶段，根据代码中的赋值情况再进行一次初始化。** 非静态成员变量   ** 仅 “初始化”&lt;strong&gt; 阶段赋值。根据代码中的赋值情况，代码不赋值直接赋默认值，有赋值则等于代码中的赋值。对象实例化后，该变量随 java 对象分配到&lt;/strong&gt; java 堆中。&lt;strong&gt;方法区的局部变量没有初始化  &lt;strong&gt;原因就是类方法中的代码，是在字节码执行的时候，才会被运行到，此时局部变量是存储在&lt;/strong&gt;虚拟机栈 - 栈帧中的局部变量表中&lt;/strong&gt;。局部变量定义了但是没有赋值是不能使用的。_可能的原因如下，当我们新建一个对象时，Java 会在 Heap 中申请一块内存区域用以存放类的数据。而成员变量就是类的数据，也是放在这块内存区域中的。只需要 JVM 在申请内存的时候顺便把整块区域都置为零即可完成初始化，方便快捷。__&lt;em&gt;而对于方法的局部变量，是在线程的 Stack 中，当然 Stack 他也可以帮我们初始化，不过有一个问题。对于有些局部变量，在方法的一开始是没有的，有些在循环中的局部变量是要反复的声明多次的。有些局部变量作用域结束后，另一个局部变量又会占用这个局部变量的位置。&lt;/em&gt;&lt;strong&gt;总结：从技术上来讲，局部变量一般来说总量大，生命周期短，JVM 进行初始话开销较大；从业务上讲，局部变量一般用于实际问题下的运算，很少会用到默认值，赋值意义不大；从编程思想上讲，局部变量不初始化，而是报错提醒，更有助于程序员减少开发过程中出现缺陷的可能。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-为什么枚举类的构造器必须私有&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#5-为什么枚举类的构造器必须私有&#34;&gt;#&lt;/a&gt; 5. 为什么枚举类的构造器必须私有？&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JldHRhcndhbmcvYXJ0aWNsZS9kZXRhaWxzLzI3MjYyODA5&#34;&gt;Java 中的枚举类为何不能有 public 构造器_BUAA 海海的博客 - CSDN 博客&lt;/span&gt;&lt;/p&gt;
</content>
        <updated>2023-09-07T09:59:14.000Z</updated>
    </entry>
    <entry>
        <id>https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/</id>
        <title>原码反码补码</title>
        <link rel="alternate" href="https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/"/>
        <content type="html">&lt;p&gt;关于原码反码补码，首先，明确三码之间的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正数三码合一&lt;/li&gt;
&lt;li&gt;负数三码的关系如下：
&lt;ul&gt;
&lt;li&gt;原 ↔ 反 (高位符号位不变)
&lt;ul&gt;
&lt;li&gt;原码 = ~ 反码&lt;/li&gt;
&lt;li&gt;反码 = ~ 原码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反 ↔ 补
&lt;ul&gt;
&lt;li&gt;补码 = 反码 + 1&lt;/li&gt;
&lt;li&gt;反码 = 补码 - 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原 ↔ 补
&lt;ul&gt;
&lt;li&gt;原码 = ~ 反码 = ~ (补码 - 1)&lt;/li&gt;
&lt;li&gt;补码 = 反码 + 1 = ~ 原码 + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：3 的原码: 0000 00113 的反码: 0000 00113 的补码: 0000 0011-3 的原码: 1000 0011, 即将 3 的原码最高位换成 1 以表示负数 - 3 的反码: 1111 1100, 注意符号位不变 - 3 的补码: 1111 1101&lt;/p&gt;
&lt;p&gt;原码：二进制原始表示。现代计算机集成电路通过高低电位只能表示 0 和 1. 也是计算机 打印和显示 的形式.&lt;/p&gt;
&lt;p&gt;反码：反码计算是将符号位引入计算的一种机制。减法器考虑借位等问题实际上会导致比加法器运算更加复杂。减去一个数相当于加上一个负数。但是如果使用原码进行加减运算，可以尝试 3 + (-2) 使用原码计算:  0000 0011+1000 0010=1000 0101 会得到结果为 - 5, 显然并不符合常理。于是引入反码运算概念，使用反码进行上述运算  0000 0011+1111 1101=0000 0001 关于结果最后面那个 1 , 是由于高位溢出需要在低位上加 1. 他的原码为自身，所以结果为 1 , 符合常识。尝试计算 1 + (-1)  0000 0001+1111 1110=1111 1111 他的原码为 1000 0000 结果为 -0, 而 0000 0000 也表示 0.&lt;/p&gt;
&lt;p&gt;补码：反码的计算已经可以囊括符号位，但是存在瑕疵，请思考 0 和 -0 的表示。循环进位的溢出也需要另外的逻辑判断，显然浪费了计算资源。使用补码运算，高位溢出可以直接舍弃。并且解决了我们使用补码来尝试计算 3 + (-2)  0000 0011+1111 1110=0000 0001 可以发现有高位溢出问题，但是可以舍弃高位溢出的数字，也可以得到正确答案。再尝试计算 1 + (-1)  0000 0001+1111 1111=0000 0000 结果为 0. 解决了反码存在的瑕疵。而原来的 1000 0000 则表示 -128. 计算机中使用 补码 进行 整型 的编码和运算，这就是为什么 MAX_INTEGER + 1 = MIN_INTEGER. 而可以这么做的原理也和同余有着千丝万缕的联系.&lt;/p&gt;
</content>
        <updated>2023-09-07T09:59:14.000Z</updated>
    </entry>
    <entry>
        <id>https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%96%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E9%97%B4%E7%B4%A2%E5%BC%95%EF%BC%9F/</id>
        <title>如何安全的取到数组的中间索引？</title>
        <link rel="alternate" href="https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%96%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E9%97%B4%E7%B4%A2%E5%BC%95%EF%BC%9F/"/>
        <content type="html">&lt;p&gt;给你一个数组  &lt;code&gt;arr&lt;/code&gt; ，取  &lt;code&gt;[l, r]&lt;/code&gt;  范围内的中间值，很简单吧，直接  &lt;code&gt;arr[(l + r) / 2]&lt;/code&gt;  ？大错特错，这里的  &lt;code&gt;l + r&lt;/code&gt;  具有潜在的安全隐患，即可能会在某些情况下溢出，即  &lt;code&gt;l + r &amp;gt; Integer.MAX_VALUE&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;方法一l-r-l-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#方法一l-r-l-2&#34;&gt;#&lt;/a&gt; 方法一：l + (r - l) / 2&lt;/h3&gt;
&lt;p&gt;这样可以使用  &lt;code&gt;r - l&lt;/code&gt;  来降低操作数的大小，避免了出现溢出问题&lt;/p&gt;
&lt;h3 id=&#34;方法二l-r-l-1&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#方法二l-r-l-1&#34;&gt;#&lt;/a&gt; 方法二：l + ((r - l) &amp;gt;&amp;gt; 1)&lt;/h3&gt;
&lt;p&gt;相较于法一主要是使用了位运算符，有助于提高运算速度&lt;/p&gt;
</content>
        <updated>2023-09-07T09:59:14.000Z</updated>
    </entry>
    <entry>
        <id>https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%B0%83%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</id>
        <title>如何正确的调用泛型方法</title>
        <link rel="alternate" href="https://zrgzs.github.io/guide/2023/09/07/%E5%86%B7%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%B0%83%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/"/>
        <content type="html">&lt;p&gt;object.&lt;String&gt;methodName(…)&lt;/p&gt;
</content>
        <updated>2023-09-07T09:59:14.000Z</updated>
    </entry>
</feed>
