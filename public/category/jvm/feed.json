{
    "version": "https://jsonfeed.org/version/1",
    "title": "卓软信息工作室 • All posts by \"jvm\" category",
    "description": "",
    "home_page_url": "https://zrgzs.github.io/guide",
    "items": [
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/JVM/README/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/JVM/README/",
            "title": "README",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<p>本目录是阅读《深入理解 Java 虚拟机》第三版后摘抄的部分知识。具体来说：</p>\n<blockquote>\n<p>这样的是摘抄的</p>\n</blockquote>\n<ul>\n<li>这样的是自己写的理解</li>\n</ul>\n<p>好的博客：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vY29sdW1uLzY5NjU0ODA1MzgyMDc0MjA0NTM=\">从零开始学 JVM - 迷途小沙弥的专栏 - 掘金</span></p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/JVM/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/JVM/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/",
            "title": "第三章 垃圾收集器与内存分配策略",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<blockquote>\n<p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</p>\n</blockquote>\n<h1 id=\"31-概述\"><a class=\"markdownIt-Anchor\" href=\"#31-概述\">#</a> 3.1 概述</h1>\n<blockquote>\n<p>第 2 章介绍了 Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。<br>\n而 Java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，本文后续讨论中的 “内存” 分配与回收也仅仅特指这一部分内存。</p>\n</blockquote>\n<ul>\n<li>运行时数据区中\n<ul>\n<li>程序计数器、虚拟机栈、本地方法栈 随线程而生，随线程而灭。</li>\n<li>堆、方法区 却具有不确定性。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"32-对象已死\"><a class=\"markdownIt-Anchor\" href=\"#32-对象已死\">#</a> 3.2 对象已死？</h1>\n<blockquote>\n<p>在堆里面存放着 Java 世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还 “存活” 着，哪些已经 “死去”（“死去” 即不可能再被任何途径使用的对<br>\n象）了。</p>\n</blockquote>\n<h2 id=\"321-引用计数算法\"><a class=\"markdownIt-Anchor\" href=\"#321-引用计数算法\">#</a> 3.2.1 引用计数算法</h2>\n<blockquote>\n<p>很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>\n</blockquote>\n<ul>\n<li>介绍了一下算法原理。</li>\n</ul>\n<blockquote>\n<p>也有一些比较著名的案例，例如微软 COM（Component Object Model）技术、使用 ActionScript 3 的 FlashPlayer、Python 语言以及在游戏脚本领域得到许多应用的 Squirrel 中都使用了引用计数算法进行内存管理。</p>\n</blockquote>\n<ul>\n<li>引用计数算法的应用。</li>\n</ul>\n<blockquote>\n<p>但是，在 Java 领域，至少主流的 Java 虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。<br>\n举个简单的例子，请看代码清单 3-1 中的 testGC () 方法：对象  <code>objA</code>  和 <code>objB</code>  都有字段 <code>instance</code>   ，赋值令 objA.instance=objB 及 objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</p>\n</blockquote>\n<ul>\n<li>引用计数算法的缺陷：很难解决循环引用。</li>\n</ul>\n<h2 id=\"322-可达性分析算法\"><a class=\"markdownIt-Anchor\" href=\"#322-可达性分析算法\">#</a> 3.2.2 可达性分析算法</h2>\n<blockquote>\n<p>这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。</p>\n</blockquote>\n<blockquote>\n<p>如图 3-1 所示，对象 object 5、object 6、object 7 虽然互有关联，但是它们到 GC Roots 是不可达的，因此它们将会被判定为可回收的对象。</p>\n</blockquote>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220306.jpg\" alt=\"image.png\"></p>\n<blockquote>\n<p>在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：</p>\n<ul>\n<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>\n<li>在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。</li>\n<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>\n<li>在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象。</li>\n<li>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>\n<li>所有被同步锁（synchronized 关键字）持有的对象。</li>\n<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li>\n<li>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象 “临时性” 地加入，共同构成完整 GC Roots 集合。</li>\n</ul>\n</blockquote>\n<h2 id=\"323-再谈引用\"><a class=\"markdownIt-Anchor\" href=\"#323-再谈引用\">#</a> 3.2.3 再谈引用</h2>\n<blockquote>\n<p>在 JDK 1.2 版之前，Java 里面的引用是很传统的定义：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、某个对象的引用。</p>\n</blockquote>\n<blockquote>\n<p>在 JDK 1.2 版之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软<br>\n引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>强引用是最传统的 “引用” 的定义，是指在程序代码之中普遍存在的引用赋值，即类似 “Object obj=new Object ()” 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>\n<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用。</li>\n<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用。</li>\n<li>虚引用也称为 “幽灵引用” 或者 “幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</li>\n</ul>\n</blockquote>\n<h2 id=\"324-生存还是死亡\"><a class=\"markdownIt-Anchor\" href=\"#324-生存还是死亡\">#</a> 3.2.4 生存还是死亡？</h2>\n<blockquote>\n<p>即使在可达性分析算法中判定为不可达的对象，也不是 “非死不可” 的，这时候它们暂时还处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize () 方法。假如对象没有覆盖 finalize () 方法，或者 finalize () 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为 “没有必要执行”。</p>\n</blockquote>\n<blockquote>\n<p>如果这个对象被判定为确有必要执行 finalize () 方法，那么该对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize () 方法。这里所说的 “执行” 是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的 finalize () 方法执行缓慢，或者更极端地发生了死循环，将很可能导致 F-Queue 队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p>\n</blockquote>\n<blockquote>\n<p>finalize () 方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize () 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出 “即将回收” 的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单 3-2 中我们可以看到一个对象的 finalize () 被执行，但是它仍然可以存活。</p>\n</blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>* 此代码演示了两点：</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>* 1. 对象可以在被 GC 时自我拯救。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>* 2. 这种自救的机会只有一次，因为一个对象的 finalize () 方法最多只会被系统自动调用一次</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>* @author zzm</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>*/</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FinalizeEscapeGC</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">FinalizeEscapeGC</span> <span class=\"token constant\">SAVE_HOOK</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">isAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    \t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yes, i am still alive :)\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token annotation punctuation\">@Override</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Throwable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    \t<span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"finalize method executed!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token class-name\">FinalizeEscapeGC</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SAVE_HOOK</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Throwable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token constant\">SAVE_HOOK</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FinalizeEscapeGC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token comment\">// 对象第一次成功拯救自己</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token constant\">SAVE_HOOK</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token comment\">// 因为 Finalizer 方法优先级很低，暂停 0.5 秒，以等待它</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">SAVE_HOOK</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        \t<span class=\"token constant\">SAVE_HOOK</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        \t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no, i am dead :(\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token comment\">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token constant\">SAVE_HOOK</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token comment\">// 因为 Finalizer 方法优先级很低，暂停 0.5 秒，以等待它</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">SAVE_HOOK</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        \t<span class=\"token constant\">SAVE_HOOK</span><span class=\"token punctuation\">.</span><span class=\"token function\">isAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        \t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no, i am dead :(\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><pre><code>finalize method executed!\nyes, i am still alive :)\nno, i am dead :(\n</code></pre>\n<blockquote>\n<p>还有一点需要特别说明，上面关于对象死亡时 finalize () 方法的描述可能带点悲情的艺术加工，笔者并不鼓励大家使用这个方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它并不能等同于 C 和 C<ins> 语言中的析构函数，而是 Java 刚诞生时为了使传统 C、C</ins> 程序员更容易接受 Java 所做出的一项妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。有些教材中描述它适合做 “关闭外部资源” 之类的清理性工作，这完全是对 finalize () 方法用途的一种自我安慰。finalize () 能做的所有工作，使用 try-finally 或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉 Java 语言里面的这个方法。</p>\n</blockquote>\n<h2 id=\"325-回收方法区\"><a class=\"markdownIt-Anchor\" href=\"#325-回收方法区\">#</a> 3.2.5 回收方法区</h2>\n<blockquote>\n<p>有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java 虚<br>\n拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载），方法区垃圾收集的 “性价比” 通常也是比较低的：在 Java 堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收 70% 至 99% 的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>\n</blockquote>\n<blockquote>\n<p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收 Java 堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串 “java” 曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是 “java”，换句话说，已经没有任何字符串对象引用常量池中的 “java” 常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个 “java” 常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。<br>\n判定一个常量是否 “废弃” 还是相对简单，而要判定一个类型是否属于 “不再被使用的类” 的条件就<br>\n比较苛刻了。需要同时满足下面三个条件：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</li>\n<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方 法。</li>\n</ul>\n</blockquote>\n<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是 “被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了 - Xnoclassgc 参数进行控制，还可以使用 - verbose：class 以及 - XX：+TraceClass-Loading、-XX：+TraceClassUnLoading 查看类加载和卸载信息，其中 - verbose：class 和 - XX：+TraceClassLoading 可以在 Product 版的虚拟机中使用，-XX：+TraceClassUnLoading 参数需要 FastDebug 版 [1] 的虚拟机支持。</p>\n<blockquote>\n<p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>\n</blockquote>\n<ul>\n<li>方法区的垃圾收集性价比较低，且《Java 虚拟机规范》也没要求，有些垃圾收集器就没有实现（例如 ZGC）。</li>\n</ul>\n<h1 id=\"33-垃圾收集算法\"><a class=\"markdownIt-Anchor\" href=\"#33-垃圾收集算法\">#</a> 3.3 垃圾收集算法</h1>\n<blockquote>\n<p>垃圾收集算法的实现涉及大量的程序细节，且各个平台的虚拟机操作内存的方法都有差异，在本节中我们暂不过多讨论算法实现，只重点介绍分代收集理论和几种算法思想及其发展过程。</p>\n</blockquote>\n<h2 id=\"331-分代收集理论\"><a class=\"markdownIt-Anchor\" href=\"#331-分代收集理论\">#</a> 3.3.1 分代收集理论</h2>\n<blockquote>\n<p>分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：<br>\n1）弱分代假说：绝大多数对象都是朝生夕灭的。<br>\n2）强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p>\n</blockquote>\n<blockquote>\n<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</p>\n</blockquote>\n<blockquote>\n<p>在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 —— 因而才有了 “Minor GC”“Major GC”“Full GC” 这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法 —— 因而发展出了 “标记 - 复制算法”“标记 - 清除算法”“标记 - 整理算法” 等针对性的垃圾收集算法。</p>\n</blockquote>\n<ul>\n<li>两个假说 ➡️ 设计原则 ➡️ 针对性的垃圾收集算法</li>\n</ul>\n<blockquote>\n<p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样（实际上除了 CMS 收集器，其他都不存在只针对老年代的收集）。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：<br>\n3）跨代引用假说：跨代引用相对于同代引用来说仅占极少数。<br>\n这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。<br>\n依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为 “记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GCRoots 进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>\n</blockquote>\n<ul>\n<li>前两条假说 ➡️ 第三条假说 ➡️ 解决跨区域引用。</li>\n</ul>\n<blockquote>\n<p>刚才我们已经提到了 “Minor GC”，后续文中还会出现其他针对不同分代的类似名词，<br>\n为避免读者产生混淆，在这里统一定义：<br>\n・部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：<br>\n■ 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。<br>\n■ 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。另外请注意 “Major GC” 这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。<br>\n■ 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。<br>\n・整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p>\n</blockquote>\n<h2 id=\"332-标记-清除算法\"><a class=\"markdownIt-Anchor\" href=\"#332-标记-清除算法\">#</a> 3.3.2 标记－清除算法</h2>\n<blockquote>\n<p>最早出现也是最基础的垃圾收集算法。</p>\n</blockquote>\n<blockquote>\n<p>算法分为 “标记” 和” 清除” 两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>\n</blockquote>\n<ul>\n<li>算法步骤</li>\n</ul>\n<blockquote>\n<p>它的主要缺点有两个：第一个是执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n</blockquote>\n<ul>\n<li>缺点：\n<ul>\n<li>执行效率不稳定。</li>\n<li>内存空间的碎片化问题。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220308.jpg\" alt=\"-742952935.png\"></p>\n<h2 id=\"333-标记-复制算法\"><a class=\"markdownIt-Anchor\" href=\"#333-标记-复制算法\">#</a> 3.3.3 标记－复制算法</h2>\n<blockquote>\n<p>标记－复制算法常被简称为复制算法。</p>\n</blockquote>\n<blockquote>\n<p>为了解决标记－清除算法面对大量可回收对象时执行效率低的问题。</p>\n</blockquote>\n<blockquote>\n<p>1969 年 Fenichel 提出了一种称为 “半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>\n</blockquote>\n<ul>\n<li>\n<p>算法步骤：</p>\n<ol>\n<li>将内存分为大小相等的两块。每次只使用其中一块。\t2. 当其中一块内存使用完了，就将存活的对象复制到另一块中。\t3. 清除上一次使用的那块内存区域。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p>\n</blockquote>\n<ul>\n<li>算法缺点：空间浪费巨大。</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220312.jpg\" alt=\"-742925062.png\"></p>\n<blockquote>\n<p>现在的商用 Java 虚拟机大多都优先采用了这种收集算法去回收新生代，IBM 公司曾有一项专门研究对新生代 “朝生夕灭” 的特点做了更量化的诠释 —— 新生代中的对象有 98% 熬不过第一轮收集。因此并不需要按照 1∶1 的比例来划分新生代的内存空间。</p>\n</blockquote>\n<blockquote>\n<p>在 1989 年，Andrew Appel 针对具备 “朝生夕灭” 特点的对象，提出了一种更优化的半区复制分代策略，现在称为 “Appel 式回收”。HotSpot 虚拟机的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局 [1]。Appel 式回收的具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8∶1，也即每次新生代中可用内存空间为整个新生代容量的 90%（Eden 的 80% 加上一个 Survivor 的 10%），只有一个 Survivor 空间，即 10% 的新生代是会被 “浪费” 的。当然，98% 的对象可被回收仅仅是 “普通场景” 下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于 10% 的对象存活，因此 Appel 式回收还有一个充当罕见情况的 “逃生门” 的安全设计，当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p>\n</blockquote>\n<ul>\n<li>Eden 和 Survivor 的大小比例是 8:1。</li>\n<li>先使用 Eden 和 Survivor。</li>\n<li>当一次回收后， Survivor 的空间放不下对象时，会通过分配担保机制直接进入老年代。</li>\n</ul>\n<h2 id=\"343-标记-整理算法\"><a class=\"markdownIt-Anchor\" href=\"#343-标记-整理算法\">#</a> 3.4.3 标记－整理算法</h2>\n<blockquote>\n<p>针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的 “标记 - 整理”（Mark-Compact）算法，其中的标记过程仍然与 “标记 - 清除” 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，示意图如下所示。</p>\n</blockquote>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220314.jpg\" alt=\"-1550306413.png\"></p>\n<blockquote>\n<p>是否移动回收后的存活对象是一项优缺点并存的风险决 * 策。</p>\n</blockquote>\n<blockquote>\n<p>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行 [1]，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为 “Stop The World”[2]。<br>\n但如果跟标记 - 清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过 “分区空闲分配链表” 来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。</p>\n</blockquote>\n<ul>\n<li>移动存活对象 －－－》 会导致 Stop The World，导致用户线程暂停</li>\n<li>不移动存活对象 －－》 会导致内存空间碎片化，影响应用程序的吞吐量</li>\n</ul>\n<blockquote>\n<p>HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记 - 整理算法的，而关注延迟的 CMS 收集器则是基于标记 - 清除算法的，这也从侧面印证这点。</p>\n</blockquote>\n<blockquote>\n<p>另外，还有一种 “和稀泥式” 解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记 - 清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记 - 整理算法收集一次，以获得规整的内存空间。前面提到的基于标记 - 清除算法的 CMS 收集器面临空间碎片过多时采用的就是这种处理办法。</p>\n</blockquote>\n<ul>\n<li>CMS 收集器会暂时容忍空间碎片，当空间碎片过多时再采用标记－整理算法。</li>\n</ul>\n<h1 id=\"34-hotspot-的算法细节实现\"><a class=\"markdownIt-Anchor\" href=\"#34-hotspot-的算法细节实现\">#</a> 3.4 HotSpot 的算法细节实现</h1>\n<h2 id=\"341-根节点枚举\"><a class=\"markdownIt-Anchor\" href=\"#341-根节点枚举\">#</a> 3.4.1 根节点枚举</h2>\n<blockquote>\n<p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。</p>\n</blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>className<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> className <span class=\"token operator\">=</span> <span class=\"token string\">\"MyClass\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getOneInteger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/JVM/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/JVM/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/",
            "title": "第二章 Java 内存区域与内存溢出异常",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h1 id=\"22-运行时数据区\"><a class=\"markdownIt-Anchor\" href=\"#22-运行时数据区\">#</a> 2.2 运行时数据区</h1>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220316.jpg\" alt=\"image.png\"></p>\n<h1 id=\"221-程序计数器\"><a class=\"markdownIt-Anchor\" href=\"#221-程序计数器\">#</a> 2.2.1 程序计数器</h1>\n<blockquote>\n<p>是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\n</blockquote>\n<ul>\n<li>记录当前代码跑到哪里了</li>\n</ul>\n<blockquote>\n<p>此内存区域是唯一一个在《Java 虚拟机规范》中没有规定任何 <code>OutOfMemoryError</code>  情况的区域。</p>\n</blockquote>\n<h1 id=\"222-虚拟机栈\"><a class=\"markdownIt-Anchor\" href=\"#222-虚拟机栈\">#</a> 2.2.2 虚拟机栈</h1>\n<blockquote>\n<p>生命周期与线程相同</p>\n</blockquote>\n<ul>\n<li>启动一个新线程的时候会创建一个虚拟机栈，同时关闭一个线程也将销毁这个虚拟机栈</li>\n</ul>\n<blockquote>\n<p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n</blockquote>\n<ul>\n<li>每调用一个方法，虚拟机栈里就会新建一个栈帧来存储该方法的各项信息</li>\n</ul>\n<blockquote>\n<p>经常有人把 Java 内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的 C、C++ 程序的内存布局结构，在 Java 语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是 “堆和 “栈” 两块。其中，“堆” 在稍后笔者会专门讲述，而 “栈” 通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。</p>\n</blockquote>\n<ul>\n<li>内存不止栈和堆</li>\n</ul>\n<h3 id=\"2221-局部变量表\"><a class=\"markdownIt-Anchor\" href=\"#2221-局部变量表\">#</a> 2.2.2.1 局部变量表</h3>\n<blockquote>\n<p>存放了编译期可知的各种 Java 虚拟机基本数据类型（ <code>boolean</code> 、 <code>byte</code> 、 <code>char</code> 、 <code>short</code> 、 <code>int</code> 、  <code>float</code> 、 <code>long</code> 、 <code>double</code> ）、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。</p>\n</blockquote>\n<ul>\n<li>基本类型</li>\n<li>对象引用</li>\n<li>返回地址</li>\n</ul>\n<blockquote>\n<p>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中 64 位长度的 <code>long</code>  和 <code>double</code>  类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>\n</blockquote>\n<ul>\n<li>long 和 double 占用两个槽，其余一个槽。槽的大小由虚拟机决定</li>\n<li>方法需要在栈帧中分配多大的局部变量空间是完全确定的</li>\n<li>在方法运行期间不会改变局部变量表的大小</li>\n</ul>\n<h3 id=\"为什么栈帧大小可以完全确定\"><a class=\"markdownIt-Anchor\" href=\"#为什么栈帧大小可以完全确定\">#</a> 为什么栈帧大小可以完全确定？</h3>\n<p>因为 Java 中变量的类型分为基本类型和引用类型，而每一种类型所占用的槽的数量是确定的，所以在编译器即可确定一个方法中到底需要多少个槽。</p>\n<blockquote>\n<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 <code>StackOverflowError</code>  异常；如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 <code>OutOfMemoryError</code>  异常。</p>\n</blockquote>\n<blockquote>\n<p>HotSpot 虚拟机的栈容量是不可以动态扩展的，以前的 Classic 虚拟机倒是可以。所以在 HotSpot 虚拟机上是不会由于虚拟机栈无法扩展而导致 <code>OutOfMemoryError</code>  异常 —— 只要线程申请栈空间成功了就不会有 OOM，但是如果申请时就失败，仍然是会出现 OOM 异常的。</p>\n</blockquote>\n<h3 id=\"2222-操作数栈\"><a class=\"markdownIt-Anchor\" href=\"#2222-操作数栈\">#</a> 2.2.2.2 操作数栈</h3>\n<p>// TODO</p>\n<h3 id=\"2223-动态连接\"><a class=\"markdownIt-Anchor\" href=\"#2223-动态连接\">#</a> 2.2.2.3 动态连接</h3>\n<p>// TODO</p>\n<h3 id=\"2224-方法出口\"><a class=\"markdownIt-Anchor\" href=\"#2224-方法出口\">#</a> 2.2.2.4 方法出口</h3>\n<p>// TODO</p>\n<h2 id=\"223-本地方法栈\"><a class=\"markdownIt-Anchor\" href=\"#223-本地方法栈\">#</a> 2.2.3 本地方法栈</h2>\n<ul>\n<li>和虚拟机栈作用相似，不过本地方法栈是为本地方法服务，即被 native 修饰的方法</li>\n</ul>\n<h2 id=\"224-java-堆\"><a class=\"markdownIt-Anchor\" href=\"#224-java-堆\">#</a> 2.2.4 Java 堆</h2>\n<blockquote>\n<p>在虚拟机启动时创建。</p>\n</blockquote>\n<blockquote>\n<p>逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说 Java 对象实例都分配在堆上也渐渐变得不是那么绝对了。</p>\n</blockquote>\n<ul>\n<li>// TODO ？？？？</li>\n</ul>\n<blockquote>\n<p>Java 堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的 Java 虚拟机都是按照可扩展来实现的（通过参数 <code>-Xmx</code>  和 <code>-Xms</code>  设定）。</p>\n</blockquote>\n<blockquote>\n<p>如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code>  异常。</p>\n</blockquote>\n<h2 id=\"225-方法区\"><a class=\"markdownIt-Anchor\" href=\"#225-方法区\">#</a> 2.2.5 方法区</h2>\n<blockquote>\n<p>用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>\n</blockquote>\n<h3 id=\"为什么把方法区称为永久代\"><a class=\"markdownIt-Anchor\" href=\"#为什么把方法区称为永久代\">#</a> 为什么把方法区称为永久代？</h3>\n<blockquote>\n<p>因为仅仅是当时的 HotSpot 虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot 的垃圾收集器能够像管理 Java 堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。</p>\n</blockquote>\n<h3 id=\"使用永久代来实现方法区的坏处\"><a class=\"markdownIt-Anchor\" href=\"#使用永久代来实现方法区的坏处\">#</a> 使用永久代来实现方法区的坏处</h3>\n<blockquote>\n<p>但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了 Java 应用更容易遇到内存溢出的问题（永久代有 <code>-XX：MaxPermSize</code>  的上限，即使不设置也有默认大小，而 J9 和 JRockit 只要没有触碰到进程可用内存的上限，例如 32 位系统中的 4GB 限制，就不会出问题），而且有极少数方法（例如 <code>String::intern()</code> ）会因永久代的原因而导致不同虚拟机下有不同的表现。当 Oracle 收购 BEA 获得了 JRockit 的所有权后，准备把 JRockit 中的优秀功能，譬如 Java Mission Control 管理工具，移植到 HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。</p>\n</blockquote>\n<h3 id=\"hotspot开发团队的挽救措施\"><a class=\"markdownIt-Anchor\" href=\"#hotspot开发团队的挽救措施\">#</a> HotSpot 开发团队的挽救措施</h3>\n<blockquote>\n<p>考虑到 HotSpot 未来的发展，在 JDK 6 的时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了 JDK 7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</p>\n</blockquote>\n<ul>\n<li>JDK 6 及以下：\n<ul>\n<li>方法区的实现是永久代</li>\n</ul>\n</li>\n<li>JDK 7：\n<ul>\n<li>将原本放在永久代的 ** 字符串常量池、静态变量 ** 等移出</li>\n</ul>\n</li>\n<li>JDK 8：\n<ul>\n<li>完全废弃永久代，改用在本地内存中实现的元空间来代替</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"永久代是什么\"><a class=\"markdownIt-Anchor\" href=\"#永久代是什么\">#</a> 永久代是什么？</h3>\n<p>// TODO</p>\n<h3 id=\"元空间是什么\"><a class=\"markdownIt-Anchor\" href=\"#元空间是什么\">#</a> 元空间是什么？</h3>\n<p>// TODO</p>\n<blockquote>\n<p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError</code>  异常。</p>\n</blockquote>\n<h2 id=\"226-运行时常量池\"><a class=\"markdownIt-Anchor\" href=\"#226-运行时常量池\">#</a> 2.2.6 运行时常量池</h2>\n<blockquote>\n<p>是方法区的一部分。</p>\n</blockquote>\n<blockquote>\n<p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>\n</blockquote>\n<ul>\n<li>存放：\n<ul>\n<li>类的版本</li>\n<li>字段</li>\n<li>方法</li>\n<li>接口</li>\n<li>常量池表\n<ul>\n<li>字面量</li>\n<li>符号引用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>不过一般来说，除了保存 Class 文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p>\n</blockquote>\n<h3 id=\"符号引用直接引用\"><a class=\"markdownIt-Anchor\" href=\"#符号引用直接引用\">#</a> 符号引用？？直接引用？？</h3>\n<p>// TODO</p>\n<h2 id=\"227-直接内存\"><a class=\"markdownIt-Anchor\" href=\"#227-直接内存\">#</a> 2.2.7 直接内存</h2>\n<blockquote>\n<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 <code>OutOfMemoryError</code>  异常出现，所以我们放到这里一起讲解。</p>\n</blockquote>\n<blockquote>\n<p>在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 <code>DirectByteBuffer</code>  对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。<br>\n显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP 分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 - Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 <code>OutOfMemoryError</code>  异常。</p>\n</blockquote>\n<h1 id=\"23-hotspot虚拟机对象探秘\"><a class=\"markdownIt-Anchor\" href=\"#23-hotspot虚拟机对象探秘\">#</a> 2.3 HotSpot 虚拟机对象探秘</h1>\n<h2 id=\"231-对象的创建\"><a class=\"markdownIt-Anchor\" href=\"#231-对象的创建\">#</a> 2.3.1 对象的创建</h2>\n<blockquote>\n<p>（文中讨论的对象限于普通 Java 对象，不包括数组和 Class 对象等）</p>\n</blockquote>\n<blockquote>\n<p>当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>\n</blockquote>\n<ul>\n<li>判断该类是否已经被加载，没有则加载</li>\n</ul>\n<blockquote>\n<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存.</p>\n</blockquote>\n<blockquote>\n<p>假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为 “指针碰撞”（Bump ThePointer）。</p>\n</blockquote>\n<blockquote>\n<p>但如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为 “空闲列表”（Free List）。</p>\n</blockquote>\n<blockquote>\n<p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。</p>\n</blockquote>\n<blockquote>\n<p>因此，当使用 Serial、ParNew 等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用 CMS 这种基于清除（Sweep）算法的收集器时，理论上 [1] 就只能采用较为复杂的空闲列表来分配内存。</p>\n</blockquote>\n<blockquote>\n<p>[1] 强调 “理论上” 是因为在 CMS 的实现里面，为了能在多数情况下分配得更快，设计了一个叫作 Linear<br>\nAllocation Buffer 的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指<br>\n针碰撞方式来分配。</p>\n</blockquote>\n<ul>\n<li>内存分配方式\n<ul>\n<li>指针碰撞\n<ul>\n<li>堆内存规整时，直接从空余的内存和已使用内存的交界点开始分配内存。</li>\n</ul>\n</li>\n<li>空闲列表\n<ul>\n<li>堆内存不规整时，需要通过某种方式找到一个足够大的内存空间用来分配。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>怎么选择分配方式？\n<ul>\n<li>根据 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理 —— 实际上虚拟机是采用 CAS 配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用 TLAB，可以通过 - XX：+/-UseTLAB 参数来设定。</p>\n</blockquote>\n<ul>\n<li>线程不安全？为什么？\n<ul>\n<li>对象的内存分配过程中，主要是将对象的引用指向这个内存区域，然后进行初始化操作。而并发情况下，就有可能出现：\n<ul>\n<li>线程 A 发现内存区域 C 可以分配给对象 B</li>\n<li>线程 D 抢到 CPU 时间片，线程 D 也发现了内存区域 C 可以分配给对象 E</li>\n<li>线程 A 抢到 CPU 时间片，将对象 B 的引用指向了内存区域 C</li>\n<li>线程 D 抢到 CPU 时间片，将对象 E 的引用指向了内存区域 C</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>怎么解决？两种方式\n<ul>\n<li><code>TLAB(Thread Local AllocationBuffer)</code></li>\n<li>CAS + 失败重试</li>\n</ul>\n</li>\n<li>虚拟机是否使用 TLAB，可以通过 - XX：+/-UseTLAB 参数来设定。</li>\n</ul>\n<blockquote>\n<p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了 TLAB 的话，这一项工作也可以提前至 TLAB 分配时顺便进行。这步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>\n</blockquote>\n<ul>\n<li>初始化为 0 值是初始化对象所在的内存空间。</li>\n<li>对象中的属性的内存空间是如何分配的？？？// TODO\n<ul>\n<li>【猜想】初始化局部变量的时候会用到一种数据结构，叫 “槽”。会不会内存也是按照某种 “槽” 进行分配大小，然后就可以根据其在对象中的偏移量来确定内存中的位置。</li>\n<li>【结论】<a href=\"#IKYSo\">实例数据的分配规则</a>（语雀客户端访问异常，浏览器可以访问）</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>接下来，Java 虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用 Object::hashCode () 方法时才计算）、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，稍后会详细介绍。</p>\n</blockquote>\n<ul>\n<li>是个饼</li>\n</ul>\n<blockquote>\n<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从 Java 程序的视角看来，对象创建才刚刚开始 —— 构造函数，即 Class 文件中的<init>() 方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中 new 指令后面是否跟随 invokespecial 指令所决定，Java 编译器会在遇到 new 关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new 指令之后会接着执行<init>() 方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>\n</blockquote>\n<ul>\n<li>实例属性的 初始值是在调用 构造方法 的时候赋值的。没有调用构造方法前都是 0。</li>\n<li>类属性呢？\n<ul>\n<li>这里只是谈了普通 Java 对象，没有提及数组、Class 对象等的创建过程。又是一个坑。// TODO</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"232-对象的内存布局\"><a class=\"markdownIt-Anchor\" href=\"#232-对象的内存布局\">#</a> 2.3.2 对象的内存布局</h2>\n<blockquote>\n<p>在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>\n</blockquote>\n<ul>\n<li>对象的存储布局\n<ul>\n<li>对象头</li>\n<li>实例数据</li>\n<li>对齐填充</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>HotSpot 虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特，官方称它为 “Mark Word”。</p>\n</blockquote>\n<ul>\n<li>对象头存储对象自身的运行时数据，在 64 位的虚拟机上位 64 比特。\n<ul>\n<li>哈希码</li>\n<li>GC 分代年龄</li>\n<li>锁状态标志</li>\n<li>线程持有的锁</li>\n<li>偏向线程 ID</li>\n<li>偏向时间戳</li>\n<li>等</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>对象需要存储的运行时数据很多，其实已经超出了 32、64 位 Bitmap 结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在 32 位的 HotSpot 虚拟机中，如对象未被同步锁锁定的状态下，Mark Word 的 32 个比特存储空间中的 25 个比特用于存储对象哈希码，4 个比特用于存储对象分代年龄，2 个比特用于存储锁标志位，1 个比特固定为 0，在其他状态（轻量级锁定、重量级锁定、GC 标记、可偏向）[1] 下对象的存储内容如表 2-1 所示。</p>\n</blockquote>\n<p>表 2-1 HotSpot 虚拟机对象头 Mark Word</p>\n<table>\n<thead>\n<tr>\n<th><strong>存储内容</strong></th>\n<th><strong>标志位</strong></th>\n<th><strong>状态</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对象哈希码、对象分代年龄</td>\n<td>01</td>\n<td>未锁定</td>\n</tr>\n<tr>\n<td>指向锁记录的指针</td>\n<td>00</td>\n<td>轻量级锁定</td>\n</tr>\n<tr>\n<td>指向重量级锁的指针</td>\n<td>10</td>\n<td>膨胀（重量级锁定）</td>\n</tr>\n<tr>\n<td>空，不需要记录信息</td>\n<td>11</td>\n<td>GC 标记</td>\n</tr>\n<tr>\n<td>偏向线程 ID、偏向时间戳、对象分代年龄</td>\n<td>01</td>\n<td>可偏向</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>上表不够明确，经过查阅资料找到一张更好的表格（已经向作者大大提交了 issue 了）</li>\n<li><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220319.jpg\" alt=\"\"></li>\n<li>这里有个题外话，对运行时的对象头进行分析可以使用  <code>jol-core</code>  类库，具体使用方法自行搜索。</li>\n</ul>\n<blockquote>\n<p>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点我们会在下一节具体讨论。此外，如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p>\n</blockquote>\n<ul>\n<li>\n<p>类型指针大小与 Mark Word 大小一样</p>\n</li>\n<li>\n<p>建议阅读：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTk2Njcy\">面试被问：一个 Java 对象占多少内存？ - 腾讯云开发者社区 - 腾讯云</span></p>\n</li>\n<li>\n<p>总结：32 位虚拟机下对象头的内存布局（未开启指针压缩）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Object Header（64bits）</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th>State</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Mark Word（32bits）</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>Klass Word（32bits）</td>\n<td></td>\n</tr>\n<tr>\n<td>对象的 hashcode:25</td>\n<td></td>\n<td>对象分代年龄：4</td>\n<td>偏向锁：1（0）</td>\n<td>锁标志位：2（01）</td>\n<td>指向元空间的类型指针</td>\n<td>无锁</td>\n</tr>\n<tr>\n<td>线程 ID:23</td>\n<td>Epoch:2</td>\n<td>对象分代年龄：4</td>\n<td>偏向锁：1（1）</td>\n<td>锁标志位：2（01）</td>\n<td>指向元空间的类型指针</td>\n<td>可偏向</td>\n</tr>\n<tr>\n<td>指向线程栈中锁记录的指针：32</td>\n<td></td>\n<td></td>\n<td></td>\n<td>锁标志位：2（00）</td>\n<td>指向元空间的类型指针</td>\n<td>轻量级锁</td>\n</tr>\n<tr>\n<td>指向重量级锁 Monitor 的指针：32</td>\n<td></td>\n<td></td>\n<td></td>\n<td>锁标志位：2（10）</td>\n<td>指向元空间的类型指针</td>\n<td>重量级锁</td>\n</tr>\n<tr>\n<td>空：32</td>\n<td></td>\n<td></td>\n<td></td>\n<td>锁标志位：2（11）</td>\n<td>指向元空间的类型指针</td>\n<td>GC 标记</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（<br>\n-XX：FieldsAllocationStyle 参数）和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 HotSpot 虚拟机的 + XX：CompactFields 参数值为 true（默认就为 true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p>\n</blockquote>\n<h6 id=\"实例数据的分配规则锚点\"><a class=\"markdownIt-Anchor\" href=\"#实例数据的分配规则锚点\">#</a> 实例数据的分配规则（锚点）</h6>\n<ul>\n<li>实例数据的分配顺序规则\n<ul>\n<li>父类的变量在子类前</li>\n<li>类中变量按照：longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs）的顺序分配</li>\n</ul>\n</li>\n<li>为什么会有间隙？\n<ul>\n<li>看下文：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ExMzE0NTI0MXEvYXJ0aWNsZS9kZXRhaWxzLzEwODE2OTEyOA==\">JVM 中的对象探秘（三）- 对象的实例数据与对齐填充_java 对齐填充_很酷的小陈同学的博客 - CSDN 博客</span></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关于-xx-compactfields-参数-不生效-的一次测试\"><a class=\"markdownIt-Anchor\" href=\"#关于-xx-compactfields-参数-不生效-的一次测试\">#</a> 关于 +XX: CompactFields 参数 不生效 的一次测试</h3>\n<p>关于 “如果 HotSpot 虚拟机的 + XX：CompactFields 参数值为 true（默认就为 true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。” 这句话的测试如下。</p>\n<h4 id=\"环境\"><a class=\"markdownIt-Anchor\" href=\"#环境\">#</a> 环境</h4>\n<h5 id=\"java-环境\"><a class=\"markdownIt-Anchor\" href=\"#java-环境\">#</a> Java 环境</h5>\n<p>java version &quot;1.8.0_351&quot;Java™ SE Runtime Environment (build 1.8.0_351-b10)Java HotSpot™ 64-Bit Server VM (build 25.351-b10, mixed mode)</p>\n<h5 id=\"jvm-参数默认值\"><a class=\"markdownIt-Anchor\" href=\"#jvm-参数默认值\">#</a> JVM 参数默认值</h5>\n<p>通过命令  <code>java -XX:+PrintFlagsFinal</code>   查看参数的默认值可以发现 CompactFields 确实默认为 true，但是它似乎没有作用。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220323.jpg\" alt=\"\"></p>\n<h5 id=\"ide-环境\"><a class=\"markdownIt-Anchor\" href=\"#ide-环境\">#</a> IDE 环境</h5>\n<p>IntelliJ IDEA 2023.1 (Ultimate Edition)Build #IU-231.8109.175, built on March 28, 2023For educational use only.Runtime version: 17.0.6+10-b829.5 amd64VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.Windows 10.0GC: G1 Young Generation, G1 Old GenerationMemory: 2016MCores: 12Registry:debugger.new.tool.window.layout=truedebugger.valueTooltipAutoShowOnSelection=trueide.experimental.ui=true</p>\n<p>Non-Bundled Plugins:cn.com.pism.batslog (23.03.02.2009-RE)com.intellij.zh (231.250)leetcode-editor (8.7)com.intellij.ideolog (203.0.30.0)CMD Support (1.0.5)coderead.IdeaPlugins.maven (1.1)com.intellij.plugin.adernov.powershell (2.0.10)MavenRunHelper (4.23.222.2964.0)com.baomidou.plugin.idea.mybatisx (1.5.5)cn.yiiguxing.plugin.translate (3.4.2)</p>\n<p>Kotlin: 231-1.8.20-IJ8109.175</p>\n<h5 id=\"windows-环境\"><a class=\"markdownIt-Anchor\" href=\"#windows-环境\">#</a> Windows 环境</h5>\n<p>Win10 专业版 19045.2728</p>\n<h4 id=\"测试代码\"><a class=\"markdownIt-Anchor\" href=\"#测试代码\">#</a> 测试代码</h4>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">F2</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">byte</span> a1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">boolean</span> a2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">char</span> a3<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">short</span> a4<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">int</span> a5<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">float</span> a6<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">long</span> a7<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">double</span> a8<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token class-name\">S2</span> a9<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">S2</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">F2</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">boolean</span> b1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token function\">f2_s2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">f2_s2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLayout</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInstance</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">S2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toPrintable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\">/* 运行结果</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        从运行结果来看并没有把小字段添加到间隙中去。这里的运行结果是没有开启指针压缩的情况下的，不过这应该不会对实验结果造成影响。</pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        _2._3._2_object_memory_layout.test1.S2 object internals:</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        OFF  SZ                                     TYPE DESCRIPTION               VALUE</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>          0   8                                          (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>          8   8                                          (object header: class)    0x000002b97f14dcc0</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>         16   8                                     long F2.a7                     0</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>         24   8                                   double F2.a8                     0.0</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>         32   4                                      int F2.a5                     0</pre></td></tr><tr><td data-num=\"36\"></td><td><pre>         36   4                                    float F2.a6                     0.0</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>         40   2                                     char F2.a3</pre></td></tr><tr><td data-num=\"38\"></td><td><pre>         42   2                                    short F2.a4                     0</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>         44   1                                     byte F2.a1                     0</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>         45   1                                  boolean F2.a2                     false</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>         46   2                                          (alignment/padding gap)</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>         48   8   _2._3._2_object_memory_layout.test1.S2 F2.a9                     null</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>         56   1                                  boolean S2.b1                     false</pre></td></tr><tr><td data-num=\"44\"></td><td><pre>         57   7                                          (object alignment gap)</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>        Instance size: 64 bytes</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        Space losses: 2 bytes internal + 7 bytes external = 9 bytes total</pre></td></tr><tr><td data-num=\"47\"></td><td><pre>         */</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>从运行结果可以发现：父类变量在偏移量为 46 的位置出现了一个大小为 2 的间隙，但是 JVM 并没有将子类中大小为 1 的 boolean 变量插入到父类变量的间隙中。如果将子类的 boolean 变量插入到间隙中，这将使整个对象的大小缩减为 56 bytes，并且只浪费 1 bytes，而不是占用 64 bytes 浪费 9 bytes。这是为什么呢？我希望是我这对块知识的理解有误。</p>\n<blockquote>\n<p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是任何对象的大小都必须是 8 字节的整数倍。对象头部分已经被精心设计成正好是 8 字节的倍数（1 倍或者 2 倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>\n</blockquote>\n<ul>\n<li>也就是说一个对象的大小一定是 8 字节的整数倍。</li>\n</ul>\n<h2 id=\"233-对象的访问定位\"><a class=\"markdownIt-Anchor\" href=\"#233-对象的访问定位\">#</a> 2.3.3 对象的访问定位</h2>\n<blockquote>\n<p>创建对象自然是为了后续使用该对象，我们的 Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在《Java 虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，</p>\n</blockquote>\n<ul>\n<li>Java 程序通过 reference 数据（指向一个对象的引用）来操作堆中的对象。</li>\n<li>具体怎么通过 reference 去定位到堆中对象的具体位置由虚拟机决定。</li>\n</ul>\n<blockquote>\n<p>主流的访问方式主要有使用句柄和直接指针两种：</p>\n<ul>\n<li>如果使用句柄访问的话，Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图 2-2 所示。</li>\n<li>如果使用直接指针访问的话，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图 2-3 所示。</li>\n</ul>\n</blockquote>\n<p>详情见图：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220325.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220328.jpg\" alt=\"image.png\"></p>\n<blockquote>\n<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。<br>\n使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机 HotSpot 而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了 Shenandoah 收集器的话也会有一次额外的转发，具体可参见第 3 章），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况也十分常见。</p>\n</blockquote>\n<ul>\n<li>句柄访问\n<ul>\n<li>优点：垃圾收集时，reference 中存储的句柄地址不会改变，只需要改变句柄池中的实例数据指针即可。</li>\n</ul>\n</li>\n<li>直接指针\n<ul>\n<li>优点：速度更快，节省了一次指针定位的时间开销。</li>\n</ul>\n</li>\n<li>HotSpot 使用直接指针进行访问。</li>\n</ul>\n<h1 id=\"24-实战outofmemoryerror异常\"><a class=\"markdownIt-Anchor\" href=\"#24-实战outofmemoryerror异常\">#</a> 2.4 实战：OutOfMemoryError 异常</h1>\n<p>略。</p>\n",
            "tags": []
        }
    ]
}