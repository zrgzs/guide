{
    "version": "https://jsonfeed.org/version/1",
    "title": "卓软信息工作室 • All posts by \"中间件\" category",
    "description": "",
    "home_page_url": "https://zrgzs.github.io/guide",
    "items": [
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%9F%BA%E7%A1%80/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%9F%BA%E7%A1%80/",
            "title": "Redis基础",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-为什么要使用redis而不使用session\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么要使用redis而不使用session\">#</a> 1、为什么要使用 redis，而不使用 Session?</h2>\n<ol>\n<li>使用 Redis 而不使用传统的 Session 的主要原因是为了减轻服务器负载和提高性能。Redis 是一个高性能的基于内存的键值存储系统，相比传统的会话存储方式，使用 Redis 可以获得以下好处：\n<ul>\n<li>高性能和低延迟：Redis 的读写速度非常快，可以显著减少读写操作的延迟，提高响应速度。</li>\n<li>可扩展性：Redis 支持分布式部署，可以实现数据的负载均衡和横向扩展，提高系统的可扩展性和容量。</li>\n<li>持久化支持：Redis 提供将数据持久化到磁盘的功能，以防止数据丢失，保证数据的可靠性。</li>\n<li>丰富的功能：Redis 提供了许多附加功能，如发布 / 订阅机制、事务支持、键过期等，可以增加会话管理的灵活性和功能扩展性。</li>\n</ul>\n</li>\n<li>传统的 Session 在分布式环境下无法实现会话共享和资源共享。由于每个服务器都拥有自己的本地 Session 存储，不同服务器之间无法直接共享 Session 数据，这会导致用户在不同服务器之间会话状态不一致的问题。而使用 Redis 作为中央会话存储，可以解决这个问题，各个服务器可以共享和访问相同的会话数据，实现会话的共享和一致性。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/",
            "title": "乐观锁和悲观锁",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-基本概念\"><a class=\"markdownIt-Anchor\" href=\"#1-基本概念\">#</a> 1、基本概念</h2>\n<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p>\n<ul>\n<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>\n<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/",
            "title": "全局唯一ID",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-需求描述\"><a class=\"markdownIt-Anchor\" href=\"#1-需求描述\">#</a> 1、需求描述</h2>\n<p>当数据量很大，并且要求 ID 唯一的时候，我们需要生成唯一 ID，我们可能会根据 ID 去不同的表中对比获取数据。所以全局唯一 ID 的两个核心需求就是：① 全局唯一性② 粗略有序性</p>\n<h2 id=\"2-使用数据库自增id优缺点\"><a class=\"markdownIt-Anchor\" href=\"#2-使用数据库自增id优缺点\">#</a> 2、使用数据库自增 ID 优缺点</h2>\n<p>如果使用数据库提供的自增 ID 来实现，这样的 ID 会太明显，数据量过大需要进行分表时，两个表都进行生成唯一 ID，ID 可能会冲突。mysql 自带自增生成 id，oracle 可以用序列生成 id, 但在数据库集群环境下，扩展性不好</p>\n<h2 id=\"3-使用uuid的优缺点\"><a class=\"markdownIt-Anchor\" href=\"#3-使用uuid的优缺点\">#</a> 3、使用 UUID 的优缺点</h2>\n<p>① 生成的 ID 太长，没有任何规律性② uuid 生成全球唯一 id, 生成方式简单粗暴，本地生成，没有网络开销，效率高；缺点长度较长，没有递增趋势性，不易维护，常用于生成 token 令牌。</p>\n<h2 id=\"4-雪花id优缺点\"><a class=\"markdownIt-Anchor\" href=\"#4-雪花id优缺点\">#</a> 4、雪花 ID 优缺点</h2>\n<p>基于雪花算法 snowflake 生成全局 id，本地生成，没有网络开销，效率高，但是依赖机器时钟。</p>\n<h2 id=\"5-redis-生成全局唯一id\"><a class=\"markdownIt-Anchor\" href=\"#5-redis-生成全局唯一id\">#</a> 5、Redis 生成全局唯一 ID</h2>\n<p>基于 redis 单线程的特点生成全局唯一 id，redis 性能高，支持集群分片。为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220545.jpg\" alt=\"image.png\">ID 的组成部分：符号位：1bit，永远为 0 时间戳：31bit，以秒为单位，可以使用 69 年序列号：32bit，秒内的计数器，支持每秒产生 2^32 个不同 ID 实现：</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/",
            "title": "缓存更新策略",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"操作缓存和数据库的时候有三个问题需要考虑\"><a class=\"markdownIt-Anchor\" href=\"#操作缓存和数据库的时候有三个问题需要考虑\">#</a> 操作缓存和数据库的时候有三个问题需要考虑：</h2>\n<h3 id=\"1-删除缓存还是更新缓存\"><a class=\"markdownIt-Anchor\" href=\"#1-删除缓存还是更新缓存\">#</a> 1、删除缓存还是更新缓存？</h3>\n<p>① 更新缓存的话，每次更新数据库都需要更新缓存，无效写操作操作。② 删除缓存的话，更新数据库时让缓存失效，查询时再更新缓存。结合两者的优缺点 **，最优者为②**，减少无效的写操作。</p>\n<h3 id=\"2-如何保证缓存与数据库的操作的同时成功和失败\"><a class=\"markdownIt-Anchor\" href=\"#2-如何保证缓存与数据库的操作的同时成功和失败\">#</a> 2、 如何保证缓存与数据库的操作的同时成功和失败？</h3>\n<p>① 单体项目，将缓存与数据库操作放在一个事务中② 分布式系统，利用 TCC 等分布式事务方案</p>\n<h3 id=\"3-先操作缓存还是先操作数据库\"><a class=\"markdownIt-Anchor\" href=\"#3-先操作缓存还是先操作数据库\">#</a> 3、先操作缓存还是先操作数据库？</h3>\n<p>① 先删除缓存，再操作数据库② 先操作数据库，再删除缓存这两种操作上看似都是可以的，我们来深入探究一下到底是那种操作更胜一筹。<strong>先操作缓存再操作数据库：</strong><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220548.jpg\" alt=\"image.png\"> 假如：两个线程并行的对数据进行操作，线程 1 先删除缓存，后立即更新了数据库，使得 V 变为 20，这时线程 2 才进行查询操作，发现缓存没有命中，这时会进行查询数据库，并将查询到的信息写入到 Redis 缓存中。这样的操作是合理的。但是如果是这种情况呢？<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220550.jpg\" alt=\"image.png\"> 还是两个线程并行，线程 1 先删除了缓存，因为删除缓存的速度一般是微秒级别的，并更新数据库，因为写的操作数据库的速度要远大于操作 Redis 的速度，这时线程 2 开始了操作并查询了缓存，发现缓存不存在然后就去查询数据库，后写入缓存中。导致缓存中的数据是 V=10, 而这时线程 1 接着继续操作数据库并更新了 V=20, 这时就会导致缓存中的数据和数据库中的数据不一致。这种情况下，写入缓存的速度要远快于更新数据库的速度，所以这种情况发生的概率比较大。</p>\n<p><strong>先操作数据库，再删除缓存</strong><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220553.jpg\" alt=\"image.png\"> 线程 1、线程 2 并行执行，线程 2 先操作了数据库，将 V 变为 20，然后将缓存清空。这时线程 1 执行查询操作，没有命中就从数据库中获取数据，后写入到 Redis 中。这种情况下是看似是可行的。我们接着看下面这种情况：<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220556.jpg\" alt=\"image.png\"> 同样线程 1 和线程 2 并行执行，线程 1 先查询缓存，没有命中就去数据库中获取数据，这时线程 2 更新了数据库使得 V=20, 然后将缓存清空，这时线程 1 继续执行将获取到的信息再写入到 Redis 中，这时缓存的数据为线程 1 获取到的旧数据，这时缓存和数据库中的信息是不一致的。但是在写如缓存中的速度要远快于更新数据库的速度，并且线程 2 还对缓存进行了删除。所以这种情况的发送的改了较先删除缓存，再操作数据库发送的概率要低的多。<strong>总结：这两种方案都有可能出现数据的不一致性。最终我们选择先操作数据库后操作缓存作为我们的最佳实战策略。</strong></p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF/",
            "title": "缓存穿透、雪崩、击穿",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-缓存穿透\"><a class=\"markdownIt-Anchor\" href=\"#1-缓存穿透\">#</a> 1、缓存穿透</h2>\n<h3 id=\"1-定义\"><a class=\"markdownIt-Anchor\" href=\"#1-定义\">#</a> 1、定义</h3>\n<p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打到数据库上。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220559.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220601.jpg\" alt=\"image.png\"></p>\n<h3 id=\"2-产生原因\"><a class=\"markdownIt-Anchor\" href=\"#2-产生原因\">#</a> 2、产生原因</h3>\n<ol>\n<li>自身业务代码问题</li>\n<li>恶意攻击，爬虫造成空命中</li>\n</ol>\n<h3 id=\"3-常见的两种解决方案\"><a class=\"markdownIt-Anchor\" href=\"#3-常见的两种解决方案\">#</a> 3、常见的两种解决方案</h3>\n<h4 id=\"缓存空对象\"><a class=\"markdownIt-Anchor\" href=\"#缓存空对象\">#</a> 缓存空对象</h4>\n<p>优点：实现简单，维护方便缺点：① 额外的内存消耗② 可能造成短期的不一致<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220603.jpg\" alt=\"image.png\"></p>\n<h4 id=\"布隆过滤器\"><a class=\"markdownIt-Anchor\" href=\"#布隆过滤器\">#</a> 布隆过滤器</h4>\n<p>优点：内存占用较少，没有多余 Key 缺点：① 实现复杂② 存在误判可能<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220606.jpg\" alt=\"image.png\"> 补充：布隆过滤器，当再布隆过滤器中获取数据说是不存在时，那一定是不存在的，但是如果说是存在的话，数据实际上说不定是不存在的。所以使用布隆过滤器也可能会出现缓存穿透问题。</p>\n<h4 id=\"增强id的复杂度避免被猜测id规律\"><a class=\"markdownIt-Anchor\" href=\"#增强id的复杂度避免被猜测id规律\">#</a> 增强 id 的复杂度避免被猜测 id 规律</h4>\n<h4 id=\"做好数据的基础格式校验\"><a class=\"markdownIt-Anchor\" href=\"#做好数据的基础格式校验\">#</a> 做好数据的基础格式校验</h4>\n<h4 id=\"加强用户权限校验\"><a class=\"markdownIt-Anchor\" href=\"#加强用户权限校验\">#</a> 加强用户权限校验</h4>\n<h4 id=\"做好热点参数的限流\"><a class=\"markdownIt-Anchor\" href=\"#做好热点参数的限流\">#</a> 做好热点参数的限流</h4>\n<h2 id=\"2-缓存雪崩\"><a class=\"markdownIt-Anchor\" href=\"#2-缓存雪崩\">#</a> 2、缓存雪崩</h2>\n<h3 id=\"1-定义-2\"><a class=\"markdownIt-Anchor\" href=\"#1-定义-2\">#</a> 1、定义</h3>\n<p>缓存雪崩是指在同一时段大量的缓存 Key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220608.jpg\" alt=\"image.png\"><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220610.jpg\" alt=\"image.png\"></p>\n<h4 id=\"2-解决方案\"><a class=\"markdownIt-Anchor\" href=\"#2-解决方案\">#</a> 2、解决方案</h4>\n<ul>\n<li>给不同的 Key 的 TTL 添加随机值</li>\n<li>利用 Redis 集群提高服务的可用性</li>\n<li>给缓存业务添加降级限流策略</li>\n<li>给业务添加多级缓存</li>\n</ul>\n<h2 id=\"3-缓存击穿\"><a class=\"markdownIt-Anchor\" href=\"#3-缓存击穿\">#</a> 3、缓存击穿</h2>\n<h3 id=\"1-定义-3\"><a class=\"markdownIt-Anchor\" href=\"#1-定义-3\">#</a> 1、定义</h3>\n<p>缓存击穿问题也叫做热点 Key 问题，就是一个高并发访问并且缓存重建业务比较复杂的 Key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220613.jpg\" alt=\"image.png\"> 如上图所示的，线程 1 查询缓存但是缓存并没有命中，就开始查询数据库了，然后线程 2、3、4 也陆续查询了缓存没有命中，都去查询数据库并重建缓存。导致 db 的压力猛增，造成 dp 有可能会宕机。</p>\n<h3 id=\"2-解决方案-2\"><a class=\"markdownIt-Anchor\" href=\"#2-解决方案-2\">#</a> 2、解决方案</h3>\n<h4 id=\"1-互斥锁\"><a class=\"markdownIt-Anchor\" href=\"#1-互斥锁\">#</a> ① 互斥锁</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220615.jpg\" alt=\"image.png\"> 如上图所示：线程 1 和线程 2，线程 1 先查询缓存，但是没有命中，然后线程 1 获取互斥锁，后进行查询数据库重建数据缓存，期间线程 2 查询缓存，同样没有命中，接着线程 2 获取互斥锁，但是并没有获取到锁，所以线程 2 就在等待并重试，直到线程 1 重建数据缓存并写入缓存结束后释放互斥锁，然后线程 2 获取到互斥锁缓存命中获取到数据就可以返回了。</p>\n<h4 id=\"2-逻辑过期\"><a class=\"markdownIt-Anchor\" href=\"#2-逻辑过期\">#</a> ② 逻辑过期</h4>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907220617.jpg\" alt=\"image.png\"> 上图为逻辑过期的处理流程：线程 1 查询缓存，发现逻辑过期时间已经过期了，后获取互斥锁，然后开启新的线程：线程 2，而线程 1 直接拿旧的数据返回了，线程 2 重建数据并设置逻辑过期时间，在此时间之内线程 3 查询缓存发现逻辑过期时间过期了，并且获取互斥锁失败，那么就证明有线程在重建数据了，线程 3 就拿旧的数据返回。这时线程 2 重构数据成功，并释放了互斥锁。线程 4 过来直接直接命中缓存并且没有逻辑过期，就返回了。</p>\n<h4 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结：</h4>\n<p>两种方式各有优缺点：</p>\n<table>\n<thead>\n<tr>\n<th><strong>解决方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>互斥锁</strong></td>\n<td>没有额外的内存消耗保证一致性实现简单</td>\n<td>线程需要等待，性能受影响可能有死锁风险</td>\n</tr>\n<tr>\n<td><strong>逻辑过期</strong></td>\n<td>线程无需等待，性能较好</td>\n<td>不保证一致性有额外内存消耗实现复杂</td>\n</tr>\n</tbody>\n</table>\n<p>建议再看一篇这个文章，写的比我好多了：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGhyZWUtZmlnaHRlci9wLzE1MjUzNDUxLmh0bWw=\">十分钟彻底掌握缓存击穿、缓存穿透、缓存雪崩 - 三分恶 - 博客园</span></p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E6%A1%86%E6%9E%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/",
            "title": "黑马点评",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-json序列化时忽略null\"><a class=\"markdownIt-Anchor\" href=\"#1-json序列化时忽略null\">#</a> 1、json 序列化时忽略 NULL?</h2>\n<p>yaml 文件配置：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">jackson</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token key atrule\">default-property-inclusion</span><span class=\"token punctuation\">:</span> non_null <span class=\"token comment\"># JSON 处理时忽略非空字段</span></pre></td></tr></table></figure><h2 id=\"2-为什么使用session的方式登录不需要返回登录凭证\"><a class=\"markdownIt-Anchor\" href=\"#2-为什么使用session的方式登录不需要返回登录凭证\">#</a> 2、 为什么使用 Session 的方式登录不需要返回登录凭证？</h2>\n<p>因为使用 session 的话，浏览器第一次访问服务器，服务器会生成一个 key 为 JSESSIONID 的 cookie 的信息并会创建一个 SESSIONID 为 JSESSIONID 的 session。这样下次浏览器请求就会携带 cookie，并携带 JSESSIONID 信息，会找到与之匹配的 session。我们登录成功后需要将信息存储到这个 session 中，下次请求过来就直接从这个 session 中获取就可以了哦。</p>\n<h2 id=\"3-在redis中存储对象类型使用哪种数据结构\"><a class=\"markdownIt-Anchor\" href=\"#3-在redis中存储对象类型使用哪种数据结构\">#</a> 3、在 redis 中存储对象类型，使用哪种数据结构？</h2>\n<p>可以使用 String 结构，以 JSON 字符串来保存，比较直观：</p>\n<table name:Rose,age:18=\"\">\n<thead>\n<tr>\n<th><strong>KEY</strong></th>\n<th><strong>VALUE</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr name:Jack,age:21=\"\">\n<td>heima:user:1</td>\n<td></td>\n</tr>\n<tr>\n<td>heima:user:2</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Hash 结构可以将对象中的每个字段独立存储，可以针对单个字段做 CRUD，并且内存占用更少：</p>\n<table>\n<thead>\n<tr>\n<th><strong>KEY</strong></th>\n<th><strong>VALUE</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>field</td>\n<td>value</td>\n</tr>\n<tr>\n<td>heima:user:1</td>\n<td>name</td>\n<td>Jack</td>\n</tr>\n<tr>\n<td></td>\n<td>age</td>\n<td>21</td>\n</tr>\n<tr>\n<td>heima:user:2</td>\n<td>name</td>\n<td>Rose</td>\n</tr>\n<tr>\n<td></td>\n<td>age</td>\n<td>18</td>\n</tr>\n</tbody>\n</table>\n<p>对于取 Hash 信息，使用 stringRedisTemplate.opsForHash ().entries (key); 不能直接设置 hash 类型的过期时间，需要手动设置一下：例如：stringRedisTemplate.expire (tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</p>\n",
            "tags": []
        }
    ]
}