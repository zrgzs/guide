{
    "version": "https://jsonfeed.org/version/1",
    "title": "卓软信息工作室 • All posts by \"面试问题\" category",
    "description": "",
    "home_page_url": "https://zrgzs.github.io/guide",
    "items": [
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/",
            "title": "Session和Cookie的区别？",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<h2 id=\"1-相同点\"><a class=\"markdownIt-Anchor\" href=\"#1-相同点\">#</a> 1、相同点：</h2>\n<p><strong>cookie</strong> 和<strong> session</strong> 都是用来跟踪浏览器用户身份的会话方式。</p>\n<h2 id=\"2-工作原理\"><a class=\"markdownIt-Anchor\" href=\"#2-工作原理\">#</a> 2、工作原理</h2>\n<h3 id=\"cookie的工作原理\"><a class=\"markdownIt-Anchor\" href=\"#cookie的工作原理\">#</a> Cookie 的工作原理</h3>\n<p>（1）浏览器端第一次发送请求到服务器端（2）服务器端创建 Cookie，该 Cookie 中包含用户的信息，然后将该 Cookie 发送到浏览器端（3）浏览器端再次访问服务器端时会携带服务器端创建的 Cookie（4）服务器端通过 Cookie 中携带的数据区分不同的用户<img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221026.jpg\" alt=\"image.png\"></p>\n<p>补充：在服务器在 HTTP 响应中发送 Cookie 时，浏览器会解析响应头部的 Set-Cookie 信息，并自动将 Cookie 存储在本地。前端开发人员无需显示操作，可通过 JS 提供的 API 来操作当前页面的 Cookie。</p>\n<h3 id=\"session的工作原理\"><a class=\"markdownIt-Anchor\" href=\"#session的工作原理\">#</a> Session 的工作原理</h3>\n<p>（1）浏览器端第一次发送请求到服务器端，服务器端创建一个 Session，同时会创建一个特殊的 Cookie（name 为 JSESSIONID 的固定值，value 为 session 对象的 ID），然后将该 Cookie 发送至浏览器端（2）浏览器端发送第 N（N&gt;1）次请求到服务器端，浏览器端访问服务器端时就会携带该 name 为 JSESSIONID 的 Cookie 对象（3）服务器端根据 name 为 JSESSIONID 的 Cookie 的 value (sessionId), 去查询 Session 对象，从而区分不同用户。</p>\n<ul>\n<li>若 name 为 JSESSIONID 的 Cookie 不存在（关闭或更换浏览器），返回 1 中重新去创建 Session 与特殊的 Cookie；</li>\n<li>若 name 为 JSESSIONID 的 Cookie 存在，根据 value 中的 SessionId 去寻找 session 对象\n<ul>\n<li>value 为 SessionId 不存在（Session 对象默认存活 30 分钟），返回 1 中重新去创建 Session 与特殊的 Cookie</li>\n<li>value 为 SessionId 存在，返回 session 对象。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221028.jpg\" alt=\"image.png\"></p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221031.jpg\" alt=\"image.png\"></p>\n<h3 id=\"区别\"><a class=\"markdownIt-Anchor\" href=\"#区别\">#</a> 区别</h3>\n<p>cookie 数据保存在客户端，session 数据保存在服务端。session: 当你登陆一个网站的时候，如果 web 服务器端使用的是 session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话 sessionid，服务器根据当前 sessionid 判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。传统的会话管理技术可以选择将会话数据存储在数据库中。这通常涉及将会话数据和用户登录信息存储在同一个数据库中的不同表中，并通过某种方式将它们关联起来。cookie：sessionid 是服务器和客户端连接时候随机分配的，如果浏览器使用的是 cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了 cookie 用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释 cookie 变量，所以只要不关闭浏览器，那么 cookie 变量一直是有效的，所以能够保证长时间不掉线。补充：当涉及到大量并发用户执行登录操作时，会话管理技术可能会增加服务器的负载，并降低性能。这是因为每个用户的登录请求都需要进行 IO 操作，包括数据库查询和写入操作。这可能对数据库和服务器的性能产生一定的影响。为了处理高并发情况，可以采用一些优化措施，如使用缓存机制、数据库连接池和分布式部署等来提高性能和扩展性。</p>\n<h3 id=\"区别对比\"><a class=\"markdownIt-Anchor\" href=\"#区别对比\">#</a> 区别对比</h3>\n<p>(1) cookie 数据存放在客户的浏览器上，session 数据放在服务器上 (2) cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，如果主要考虑到安全应当使用 session (3) Session 数据会在一定时间内保存在服务器上，因此在访问量增加时，会占用服务器的内存和性能。如果关注服务器性能方面的考虑，可以使用 Cookie 来减轻服务器的负载。Cookie 存储在客户端，不会占用服务器的内存资源。(4) 单个 cookie 在客户端的限制是 4KB，每个域名在客户端存储的 Cookie 数量也是有限制的，通常是几十个或几百个。因此，需要注意 Cookie 的大小和数量，以避免超出限制。(5) 所以：将登陆信息等重要信息存放为 SESSION; 其他信息如果需要保留，可以放在 COOKIE 中</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81Servlet%EF%BC%9F/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81Servlet%EF%BC%9F/",
            "title": "简要说明一下什么是拦截器、过滤器、Servlet？",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<p>1、过滤器</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/VO%EF%BC%8CBO%EF%BC%8CPO%EF%BC%8CDO%EF%BC%8CDTO%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/VO%EF%BC%8CBO%EF%BC%8CPO%EF%BC%8CDO%EF%BC%8CDTO%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "VO，BO，PO，DO，DTO的区别",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<p><img data-src=\"https://cdn.jsdelivr.net/gh/zrgzs/images@main/images/20230907221033.jpg\" alt=\"image.png\"></p>\n<p>面对这个图，让我们先从承上启下的 DTO 开始入手</p>\n<h2 id=\"dtodata-transfer-object数据传输对象\"><a class=\"markdownIt-Anchor\" href=\"#dtodata-transfer-object数据传输对象\">#</a> DTO（Data Transfer Object）数据传输对象</h2>\n<p>这个传输通常指的前后端之间的传输 DTO 是一个比较特殊的对象，他有两种存在形式：① 在后端，他的存在形式是 java 对象，也就是在 controller 里面定义的那个，通常在后端不需要关心怎么从 json 转成 java 对象的，这个都是由一些成熟的框架帮你完成，比如 spring 框架。② 在前端，他的存在形式通常是 js 里面的对象（也可以简单理解成 json），也就是通过 ajax 请求的那个数据体</p>\n<blockquote>\n<p>服务和服务之间调用的传输对象能叫 DTO 吗？<br>\nDTO 本身的一个隐含的意义是要能够完整的表达一个业务模块的输出。<br>\n如果服务和服务之间相对独立，那就可以叫 DTO。<br>\n如果服务和服务之间不独立，每个都不是一个完整的业务模块，拆开可能仅仅是因为计算复杂度或者性能的问题，那这就不能够叫做 DTO，只能是 BO。</p>\n</blockquote>\n<h2 id=\"vovalue-object值对象\"><a class=\"markdownIt-Anchor\" href=\"#vovalue-object值对象\">#</a> VO（Value Object）值对象</h2>\n<p>VO 就是展示用的数据，不管展示方式是网页，还是客户端，还是 APP，只要是这个东西是让人看到的，这就叫 VO。VO 主要的存在形式就是 js 里面的对象（也可以简单理解成 json）</p>\n<h3 id=\"vo和dto的区别\"><a class=\"markdownIt-Anchor\" href=\"#vo和dto的区别\">#</a> VO 和 DTO 的区别</h3>\n<p>主要有两个区别一个是字段不一样，VO 根据需要会删减一些字段另一个是值不一样，VO 会根据需要对 DTO 中的值进行展示业务的解释 DTO 可能是这样的：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token property\">\"gender\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"男\"</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token property\">\"age\"</span><span class=\"token operator\">:</span><span class=\"token number\">35</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>VO 可能是：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token property\">\"gender\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"公子\"</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"popersistant-object持久对象\"><a class=\"markdownIt-Anchor\" href=\"#popersistant-object持久对象\">#</a> PO（Persistant Object）持久对象</h2>\n<p>PO 比较好理解简单说 PO 就是数据库中的记录，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象通常 PO 里面除了 get，set 之外没有别的方法对于 PO 来说，数量是相对固定的，一定不会超过数据库表的数量等同于 Entity，这俩概念是一致的</p>\n<h2 id=\"bobusiness-object业务对象\"><a class=\"markdownIt-Anchor\" href=\"#bobusiness-object业务对象\">#</a> BO（Business Object）业务对象</h2>\n<p>BO 就是 PO 的组合。简单的例子比如说 PO 是一条交易记录，BO 是一个人全部的交易记录集合对象复杂点儿的例子 PO1 是交易记录，PO2 是登录记录，PO3 是商品浏览记录，PO4 是添加购物车记录，PO5 是搜索记录，BO 是个人网站行为对象。BO 是一个业务对象，一类业务就会对应一个 BO，数量上没有限制，而且 BO 会有很多业务操作，也就是说除了 get，set 方法以外，BO 会有很多针对自身数据进行计算的方法为什么 BO 也画成横跨两层呢？原因是现在很多持久层框架自身就提供了数据组合的功能，因此 BO 有可能是在业务层由业务来拼装 PO 而成，也有可能是在数据库访问层由框架直接生成很多情况下为了追求查询的效率，框架跳过 PO 直接生成 BO 的情况非常普遍，PO 只是用来增删改使用。</p>\n<h2 id=\"bo和dto的区别\"><a class=\"markdownIt-Anchor\" href=\"#bo和dto的区别\">#</a> BO 和 DTO 的区别</h2>\n<p>这两个的区别主要是就是字段的删减 BO 对内，为了进行业务计算需要辅助数据，或者是一个业务有多个对外的接口，BO 可能会含有很多接口对外所不需要的数据，因此 DTO 需要在 BO 的基础上，只要自己需要的数据，然后对外提供在这个关系上，通常不会有数据内容的变化，内容变化要么在 BO 内部业务计算的时候完成，要么在解释 VO 的时候完成</p>\n<h2 id=\"do-data-object\"><a class=\"markdownIt-Anchor\" href=\"#do-data-object\">#</a> DO（ Data Object）</h2>\n<p>现在主要有两个版本一个是阿里巴巴的开发手册中的定义 DO（ Data Object）这个等同于上面的 PO 另一个是在 DDD（Domain-Driven Design）领域驱动设计中 DO（Domain Object）这个等同于上面的 BO</p>\n",
            "tags": []
        },
        {
            "id": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Redis%E5%92%8CSession%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/",
            "url": "https://zrgzs.github.io/guide/2023/09/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Redis%E5%92%8CSession%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/",
            "title": "谈谈你对Redis和Session的理解？",
            "date_published": "2023-09-07T09:59:14.000Z",
            "content_html": "<p>它们通常在 Web 应用程序中用于会话管理和数据存储。Redis 是一个开源的高性能键值存储系统，它以内存为主要存储介质，并支持持久化到磁盘。Redis 具有快速的读写速度、丰富的数据结构和灵活的功能，使其在各种应用场景下得到广泛应用。它不仅可以用作缓存系统，还可以作为会话存储、消息队列、计数器等多种用途。在会话管理方面，Redis 可用作分布式会话存储。传统的会话（Session）是一种用于在 Web 应用程序中跟踪用户状态的机制。当用户访问网站时，服务器会为每个用户创建一个会话，并分配一个唯一的会话标识符（通常是会话 ID）。服务器会将会话数据存储在内存中，以便在后续的请求中可以访问和更新。然而，在分布式环境中，会话数据的共享和一致性成为一个挑战。不同的服务器无法直接共享会话数据，导致用户在不同服务器之间会话状态不一致。这时，使用 Redis 作为会话存储可以解决这个问题。服务器将会话数据存储在 Redis 的内存中，各个服务器可以共享和访问相同的会话数据，实现会话的共享和一致性。Session 是一个抽象概念，用于表示在 Web 应用程序中跟踪用户状态的机制。它通常由服务器来创建和管理，并用于存储用户相关的数据。Session 数据可以包含用户的身份验证信息、用户设置、购物车数据等。传统的 Session 管理方式将会话数据存储在服务器的内存中，但在分布式环境中存在共享和一致性的问题。而使用 Redis 作为会话存储，可以实现分布式环境下的会话共享和一致性。最后：Redis 是一个高性能的键值存储系统，而 Session 是用于管理用户会话状态的概念。通过使用 Redis 作为会话存储，可以获得高性能、可扩展性、共享性和持久化支持等优势，提升会话管理的效率和可靠性。</p>\n",
            "tags": []
        }
    ]
}